___THIS DOCUMENTATION NEEDS REVIEW___

If you read it, take it carefully:

* some information might be obsolete
* there can be some senseless parts:
	* unfinished sentences
	* paraphrased paragraphs
* there can be a lot of grammatical and typo mistakes
* it still needs some reorganization

----

Here stand the modules used through RPC (Remote Procedure Call), that is by the clients (frontends) of the editor services.

Each module corresponds to a different language. They might use each other.

Technically there's no constraint about these modules, due to the fact that the RPC module doesn't make any assumption on what's inside.

However, they are intended to provide the same API, giving the services described below.

# File system layout

* `node_modules`: common resources for modules

Coming:

* `test.ls`: is used to test parsers generated by PEG.js

All the other folders are modules, please refer to their repective documentations.

# Services

## Parsing

___Describe here the model of a parser and of the data generated by the parser (node/graph, commonly known as AST) - maybe put the latter in a dedicated section, see the WEB-IDE project and also personal ones___

This is the core service, as without it you can't get the core model on which __every other service__ is based.

A parser returns a comprehensive model of a program, or part of it. It should also be able to handle updates of teh model from parts of the whole program.

### Concept
### Impact
### Implementation
### TODO

## Formatting

Formatting aims at changing a source code to give it a wanted and generally uniformed layout.

### Concept

The concept of formatting code is simple:

* input: a source code, should be a relevant piece of code
* output: a source code with the same semantics, but formatted. It is likely to have the same syntax, what changes being mainly the white spaces.

So the main part to update in the model is related to tokens, especially white spaces, and thus is about information of positions (and length).

### Impact

Formatting transforms the code, therefore it impacts almost all other features relying on positions:

* highlight: highlighting is implemented with ranges of text styles
* outline: the outline should remain the same, since the semantic should remain the same. However, if the outline either displays positions information or is linked to the editor (when you select a node in outline you jump to the corresponding position in the editor), it relies on positions
* ...

### Implementation

For now, the API only allows you to pass in a source code, and to receive the new source code.

It's up to the client (frontend) to compute lengths difference.

However, you can in the same request ask for other information to be sent, like highlighting and outlining (to avoid the overhead of making those requests by yourself after).

### TODO

* session management: the method will act on a model stored in a session, this way you will be able to pass a range (or a list of ranges) to format instead of a source code.
* _partial_ code formatting: sometimes when you ask for formatting, you ask it for a selected text, but the formatting can only be applied on a wider portion of text, to form a valid code. This could be handled only with sessions and ranges input. The method would receive a range to format, and send back the formatted source code, and the actual range that has been formatted (considering the original text as reference).


## Folding

Folding aims at giving teh possibility to hide or show back portions of the source code, generally based on semantics.

### Concept

The concept is rather simple.

A fold happens on a set of consecutive lines. Thus the output model of folding is a set of line ranges, possibly overlapping by the way.

How to compute these ranges is another story.

A foldable portion of source code is linked to semantics. In general, block statements are foldable, and every elements inside a block must be impacted.

After obtaining the AST of the source code, all nodes must be traversed. Only nodes corresponding to blocks will be processed.

Such a node should contain location information in the form of `line`, `column` (this feature is provided by the parsers I use). Just take the range of lines it spans and return it.

### Impact

This depends on frontends capabilities.

Folding doesn't change anything in the core model, it's just a visual feature. Therefore it might impact all features concerning display of the code, like for instance highlighting.

However, services like highlighting are based on the core model, and give position information related to this model, not what is visually displayed. The frontend should be able to adapt this information to the fact that portions of code are not _physically_ shown.

### Implementation

### TODO

Think about the case where there are multiple multi-lines blocks on the same line: they overlap while one is ending and the other one is starting. This would have some weird behavior when trying to fold them.

## Highlighting

___Describe here the model of highlighting (stylesheets, tokens/ranges)___

### Concept
### Impact
### Implementation
### TODO

# TODO

## Partial updates, granularity

For now, all features are implemented considering only an entire source code.

In the future, for better consistency, simplicity, performances and logic, everything should be working with the graph model, built from the AST.

For instance, a node could be attached the `foldable` property, the `type` property being already present and used for highlighting.

However, the algorithms already implemented will be useful to handle whole changes: these changes modify portions of graphs, it's like an entire source code, but nested in another.

One big thing will be handling slight changes in the graph, and updating the model in a minimum time.

## Sessions

Add a concept of _session_.

A module should be able to work on any instance of a model. Imagine you have only one instance of the module, used by several editors, for different files. If the module needs to store information about the models, to gain performances or whatever, it should be able to know on which model the client wants to work.

A session could be only linked to a file (content in general), not an editor (the client editing the file). This way, we could imagine sharing the state of a file between several editors modifying it.
