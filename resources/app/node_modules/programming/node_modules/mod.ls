require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
}



class Module
	(@parser) ~>

	_parse: ({source, rule}) -> @parser.parse source, rule



	############################################################################
	# Parse
	############################################################################

	clean-graph = (node) ->
		delete node.parent
		delete node.childrenIndex

		for child in node.children ? [] => clean-graph child
		node

	parse: -> @_parse ... |> clean-graph



	############################################################################
	# Outline
	############################################################################

	/**
	 * @fixme Without the `return` keyword it doesn't work, seems like altering the class itself. LiveScript issue (simmilar as the one for ::member = ...)
	 */
	outline-node = (node) ->
		return {
			label: "#{node._parentId || 'root'}: #{node.type.element}"
			children: [outline-node child for child in node.children ? []]
		}

	outline-simpleTree = (node) ->
		label = _.keys node .0
		children = node[label]
		return {
			label
			children: [outline-simpleTree child for child in children]
		}

	/**
	 * @fixme Why in the "specs" do I require a list of elements, while this will always be a single node (the root)?
	 */
	outline: ({source}:arg) ->
		{ast: [outline-simpleTree (@_parse arg).simpleTree!]}
		# {ast: [outline-node @_parse arg]}



exports <<< {
	Module
}
