OOP (Object Oriented Programming) library.

# TODO

* For the method factory: instead of having multiple properties like `chainable`, `output`, etc.: have one property `output`, being a string or an object, always specifying the simple kind of output - for instance `this`, `spec`, `input` or `property`. In the latter case `property`, and additional information is required (the name of the property), so you would have to provide an object.

## Factory through constructor

Be able to specify a factory to be used directly through the constructor call. This requires some limits however: the thing is to ba able to distinguish a normal call and a factory call. First, it should be available only for constructors using schemas: so the constructor should take only one argulent, which is an object. Then, there are two things that can make us do the distinction: if there are more than 1 argument, or if the single argument is not an object.

## Factories forwarding with arrays (& more...)

An example wil be easier here.

Imagine you have a class, which has a factory which takes two arguments.

Imagine know that each argument correspond to a type, and you would like to use their own factories too. But you can't! Indeed, you can't specify multiple arguments list like in [Scala](http://docs.scala-lang.org/style/declarations.html)!

However we could emulate this multiple arguments lists by passing arrays to arguments.

Example:

```javascript
Range.range({value: 0, inclusive: true}, {value: 5, inclusive: true});
// =>
Range.range([0, true], [5, true]);
```

This would require specifying which factory to use behind. Or we can enable setting a default factory up, and then using this one.

And also this would require detecting that having an array as input is for factory use, not construction.

However, this is close to the way `inputToSpec` works, and calling explicitely the factory on Array input would do the trick. Moreover it avoids types conflicts in this case.

This behavior for Array input in `inputToSpec` could be automatically added if the slot is free, but we still need a default factory to be defined.

__OOPS! This is false, as the `inputToSpec` returns a spec, not dierctly an instance like the factory does.__ However, this could work as factories definition does, with args and values maps. Handle `Object` inputs in addition to `String` and `Function` for `inputToSpec`, and then either take the maps directly, or a reference to a factory map (harder to do because we don't really expose these maps).

NB: In fact I see simmilarities between `inputToSpec` and factories:

* `inputToSpec` uses args and values maps in fact
* in this case, args and values maps can be build from both objects or simple string, the latter being equivalent to {args: {<string>: 0}}
* `inputToSpec` is a factory callable from the constructor function directly (they are _inline_), while others require static functions

We should try to combine the two concepts.

## Consistency

Change the name `methodFactory` to `Method`. Indeed, these are classes, representing OOP concepts: `Class`, `Method`, `Attribute`, `Prototype` (?), ...

## Inferrence

Implement properties inferrences: specifying the name of another spec property. So this would require applying defaults and infference a level above the property extraction: we don't consider a single property but a set of them. Why `default` too? Becaise it comes after inferrence!

This would also require processing properties like a dependency manager (they are dependent indeed).

Example:

```javascript
[
	{name: 'referenced'},
	{name: 'inferred', default: 0, inferred: 'referenced'}
]
```

If `referenced` is defined, `inferred` will have its values, otherwise `0`.

Note that in this case the order of properties definition helps. If it was reversed, it would be more difficult. Because of this combination of default and inferrence. Because if we process all properties without inference, but just default, it would be fine to reprocess all of them using inferrence. But some inferrence will fail because some properties wouldn't have their default applied, because they were waiting for inferrence first. This would occur in a case like this I guess (interdependency):

```javascript
[
	{name: 'prop1', default: 1, inferred: 'prop1'},
	{name: 'prop2', default: 2, inferred: 'prop1'}
]
```


# Callable instance issue

What's hard to maje a callable instance is that we have to manage two contexts:

* the one of the object, having own properties (instance properties), and a prototype
* the one of the function called, which should be bound to the above object context

We need to return a function anyway, these are the only objects callable.

So, let's say we manage the first context: when computing `self`, we say it's the function. No way to do something else. Then all instance properties and the prototype chain are correct.

Now let's say we want to manage the second thing, we have to bind the function to a context which is the object containing instance properties and proper prototype chain. BUT THIS IS THE FUNCTION ITSELF!

__So no way to bind it, because it returns another function, which doesn't have all these properties and prototype chain. ...or?__

Another solution would be to manage with closures maybe... And explicitely pass self.

# Class

Creates a class from the properties you gave.

Returns a constructor function generated from the given specifications.

## FIXME

* The `name` property of a function is already natively taken.

## Constructor, methods, properties, statics, factories, ...

The title of this section enumerates a bunch of usual properties we find in OOP. Here they are described.

### Constructor

Here we are talking about the constructor specification, given as input, not the actual returned constructor which is generated by this utility.

The construtor is in charge to initialize an instance of the class.

That's why sometimes people are calling it the `init` function, or something like that.

Here you can either pass a function to be called to initialize the instance, or an object specification in case of a pure object constructor without specific processing.

In the latter case, the generated constructor will not call any initialization function but use the `processProperties` utility applied on the created instance.

### Properties

Instance properties can be defined thourgh the `Object.defineProperty` method, instead of basic assignment in the constructor/init function.

Here you can specify a list of `properties` to define at construction.

For each property you can define a list of names, and one descriptor (the same to be used with the native property definition function).

### Factories



## Generated constructor

## Callable instances

## Inheritance

Simple inheritance is implemented, just provide a valid constructor function in case you want to inherit it, under the property: `parent`.

In this case, the classical JavaScript prototype inheritance is applied. Also, properties from the parent constructor are copied into the constructor of this class.

## Special factory

A special factory is always generated, under the name `factory` (assigned to the constructor).

It is special in that it can be used to avoid unecessary object constructions: in case the given input is already an instance of the class, the factory returns it directly, otherwise it forwards the single input argument to the constructor and returns the created instance.

So if you want to make a copy of an object using an already existing instance, DON'T use this special factory!

## Identification

You can set some identifications properties for the class, like:

- `displayName`: display name, supported by some engine for debugging
- `name`: the name of your class
- `id`: an id for easy programmatic reference
- `description`: a description of the class, like its documentation for instance

Display name, name and ids can be inferred from each other (depending on which ones are specified).

# Factory

Creates a factory from the given spec for the given constructor.

Classes, and thus constructors, generated by this module use specification objects as input. Sometimes other primitive values can be given as input, but they will be converted to object specifications in functions of their types. However, you can always give only ONE value.

A factory function is a way to use the positional arguments of the function instead of properties of an object.

Therefore the usual schema to create a factory is to map positional arguments to the spec object properties, and this function does that for you.

Note that factories also often use default values, so you can also directly map values to the spec object properties.

Example of mapping specification to create the factory:

```javascript
{
args: {targetProperty1: 0},
values: {targetProperty0: "default"}
}
```

This would produce an object specification (used for the constructor input) like this:

```javascript
{
targetProperty0: "default",
targetProperty1: arguments[0] // value of the first argument passed to the factory
}
```

# Method

`methodFactory`

Factory for method creation.

You can either specify a method with a function, in which case it is immediately returned, or with specifications.

To generate a method with specifications, you can provide information about:

- optional but advised: the schema of the input argument, like if you would process it with `processProperties`
- mandatory: the actual function, receiving either the result of the schema processing if provided, or all the arguments forwarded
- optional: if you want to return directly a property from the spec generated from the schema, specify its name here. Makes sense only if a schema was provided
