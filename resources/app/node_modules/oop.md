OOP (Object Oriented Programming) library.

# TODO

* For the method factory: instead of having multiple properties like `chainable`, `output`, etc.: have one property `output`, being a string or an object, always specifying the simple kind of output - for instance `this`, `spec`, `input` or `property`. In the latter case `property`, and additional information is required (the name of the property), so you would have to provide an object.

# Callable instance issue

What's hard to maje a callable instance is that we have to manage two contexts:

* the one of the object, having own properties (instance properties), and a prototype
* the one of the function called, which should be bound to the above object context

We need to return a function anyway, these are the only objects callable.

So, let's say we manage the first context: when computing `self`, we say it's the function. No way to do something else. Then all instance properties and the prototype chain are correct.

Now let's say we want to manage the second thing, we have to bind the function to a context which is the object containing instance properties and proper prototype chain. BUT THIS IS THE FUNCTION ITSELF!

__So no way to bind it, because it returns another function, which doesn't have all these properties and prototype chain. ...or?__

Another solution would be to manage with closures maybe... And explicitely pass self.

# Class

Creates a class from the properties you gave.

Returns a constructor function generated from the given specifications.

## FIXME

* The `name` property of a function is already natively taken.

## Constructor, methods, properties, statics, factories, ...

The title of this section enumerates a bunch of usual properties we find in OOP. Here they are described.

### Constructor

Here we are talking about the constructor specification, given as input, not the actual returned constructor which is generated by this utility.

The construtor is in charge to initialize an instance of the class.

That's why sometimes people are calling it the `init` function, or something like that.

Here you can either pass a function to be called to initialize the instance, or an object specification in case of a pure object constructor without specific processing.

In the latter case, the generated constructor will not call any initialization function but use the `processProperties` utility applied on the created instance.

### Properties

Instance properties can be defined thourgh the `Object.defineProperty` method, instead of basic assignment in the constructor/init function.

Here you can specify a list of `properties` to define at construction.

For each property you can define a list of names, and one descriptor (the same to be used with the native property definition function).

### Factories



## Generated constructor

## Callable instances

## Inheritance

Simple inheritance is implemented, just provide a valid constructor function in case you want to inherit it, under the property: `parent`.

In this case, the classical JavaScript prototype inheritance is applied. Also, properties from the parent constructor are copied into the constructor of this class.

## Special factory

A special factory is always generated, under the name `factory` (assigned to the constructor).

It is special in that it can be used to avoid unecessary object constructions: in case the given input is already an instance of the class, the factory returns it directly, otherwise it forwards the single input argument to the constructor and returns the created instance.

So if you want to make a copy of an object using an already existing instance, DON'T use this special factory!

## Identification

You can set some identifications properties for the class, like:

- `displayName`: display name, supported by some engine for debugging
- `name`: the name of your class
- `id`: an id for easy programmatic reference
- `description`: a description of the class, like its documentation for instance

Display name, name and ids can be inferred from each other (depending on which ones are specified).

# Factory

Creates a factory from the given spec for the given constructor.

Classes, and thus constructors, generated by this module use specification objects as input. Sometimes other primitive values can be given as input, but they will be converted to object specifications in functions of their types. However, you can always give only ONE value.

A factory function is a way to use the positional arguments of the function instead of properties of an object.

Therefore the usual schema to create a factory is to map positional arguments to the spec object properties, and this function does that for you.

Note that factories also often use default values, so you can also directly map values to the spec object properties.

Example of mapping specification to create the factory:

```javascript
{
args: {targetProperty1: 0},
values: {targetProperty0: "default"}
}
```

This would produce an object specification (used for the constructor input) like this:

```javascript
{
targetProperty0: "default",
targetProperty1: arguments[0] // value of the first argument passed to the factory
}
```

# Method

`methodFactory`

Factory for method creation.

You can either specify a method with a function, in which case it is immediately returned, or with specifications.

To generate a method with specifications, you can provide information about:

- optional but advised: the schema of the input argument, like if you would process it with `processProperties`
- mandatory: the actual function, receiving either the result of the schema processing if provided, or all the arguments forwarded
- optional: if you want to return directly a property from the spec generated from the schema, specify its name here. Makes sense only if a schema was provided
