require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
}



blockStatements = ["#{statement}Statement".toLowerCase! for statement in <[
	if
	block
	switch
	while
	dowhile
	for
	forin
	try
	let
]>]



getBlocks = (node) ->
	result = []
	switch typeof! node
	| 'Object' => if node.type?
		if node.type.toLowerCase! in blockStatements => result.push node
		for key, value of node | key not in <[type loc range raw]> => result ++= getBlocks value
	| 'Array' => for child in node => result ++= getBlocks child

	result



/**
 * Works with an Esprima AST only.
 *
 * Requires:
 * - loc
 * - comments
 *
 * Returns ranges of lines.
 */
fold = (ast) ->
	nodes = getBlocks ast.body

	# Adds comments ------------------------------------------------------------
	nodes ++= _.select ast.comments, (.type is 'Block')

	# Extracts ranges ----------------------------------------------------------
	ranges = [{start: node.loc.start.line, end: node.loc.end.line} for node in nodes]

	# Rejects single line blocks -----------------------------------------------
	ranges = _.reject ranges, -> it.start is it.end

	# Removes duplicates -------------------------------------------------------
	uniqueRanges = []
	inUniqueRanges = (range) ->
		for r in uniqueRanges => if r.start is range.start and r.end is range.end => return yes
		no
	for range in ranges => if not inUniqueRanges range => uniqueRanges.push range
	ranges = uniqueRanges

	# For a same line, sorts by end (descending) -------------------------------
	# Then sorts by start line -------------------------------------------------
	ranges = _.sortBy (_.flatten [(_.sortBy value, (.end)).reverse! for key, value of _.groupBy ranges, (.start)]), (.start)

	{folds: ranges}



/**
 * Works with an Esprima AST only.
 *
 * Requires:
 * - range
 * - loc
 * - comments
 *
 * Returns actual ranges.
 */
fold2 = (ast) ->
	nodes = getBlocks ast.body

	# Adds comments ------------------------------------------------------------
	nodes ++= _.select ast.comments, (.type is 'Block')

	# Extracts ranges ----------------------------------------------------------
	# Excludes ranges which are on one line
	ranges = [{start: node.range.0, end: node.range.1} for node in nodes | node.loc.start.line isnt node.loc.end.line]

	# Remove one lines

	{folds: ranges}




exports <<< {
	fold: fold2
}
