require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
}



blockStatements = ["#{statement}Statement".toLowerCase! for statement in <[
	if
	block
	switch
	while
	dowhile
	for
	forin
	try
	let
]>]



getBlocks = (node) ->
	result = []
	switch typeof! node
	| 'Object' => if node.type?
		if node.type.toLowerCase! in blockStatements => result.push node
		for key, value of node | key not in <[type loc range raw]> => result ++= getBlocks value
	| 'Array' => for child in node => result ++= getBlocks child

	result



/**
 *  Works with an Esprima AST only.
 */
fold = (ast) ->
	nodes = getBlocks ast.body

	# Adds comments ------------------------------------------------------------
	nodes ++= _.select ast.comments, (.type is 'Block')

	# Extracts ranges ----------------------------------------------------------
	ranges = [{start: ..loc.start.line, end: ..loc.end.line} for nodes]

	# Rejects single line blocks -----------------------------------------------
	ranges = _.reject ranges, -> it.start is it.end

	# Removes duplicates -------------------------------------------------------
	uniqueRanges = []
	inUniqueRanges = (range) ->
		for uniqueRanges => if ..start is range.start and ..end is range.end => return yes
		no
	for range in ranges => if not inUniqueRanges range => uniqueRanges.push range
	ranges = uniqueRanges

	# For a same line, sorts by end (descending) -------------------------------
	# Then sorts by start line -------------------------------------------------
	ranges = _.sortBy (_.flatten [(_.sortBy value, (.end)).reverse! for key, value of _.groupBy ranges, (.start)]), (.start)

	{folds: ranges}




exports <<< {
	fold
}
