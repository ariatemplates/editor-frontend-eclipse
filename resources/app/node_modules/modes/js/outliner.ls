############################################################################
# Outline
# TODO CLEAN THIS
############################################################################

# _outlineNode: (node) ->
# 	switch node.type
# 	| 'Program' => {
# 		label: 'Program'
# 		children: node.body
# 	}
# 	| 'VariableDeclaration' => {
# 		label: "Declarations (#{node.kind})"
# 		children: node.declarations
# 	}
# 	| 'VariableDeclarator' => {
# 		label: "#{node.id.name}#{if node.init? => " = " else ''}"
# 		children: [node.init]
# 	}
# 	| 'BinaryExpression' => {
# 		label: "Binary expression (#{node.operator})"
# 		children: [node.left, node.right]
# 	}
# 	| 'Literal' => {
# 		label: node.value
# 	}
# 	| _ => {label: '...'}


# /**
#  * Attach outline information to each node.
#  */
# _outlineTree: (node) ->
# 	children = node?links?children?list ? []
# 	for child in children => _outlineTree child

# 	outline = outlineNode node
# 	node.outline = outline

# /**
#  * Returns an outline view description.
#  *
#  * An outline is a tree describing the source code.
#  *
#  * For simplicity of use, the actual content of the tree, how the nodes are built and so on is internal, even if it can be customized.
#  *
#  * Therefore the output format of this function is low-level, and semantic-less: this is a tree, meaning a set of nodes, each containing a required label, and an optional ordered list of children nodes.
#  *
#  * See developer documentation for details about how to build this tree.
#  */
# outline = ({source, options}) ~>
# 	options ?= {}
# 		..simple ?= yes
# 		..debug ?= on

# 	ast = @_parse source
# 	# root = ast.body

# 	if not options.simple => _outlineTree ast

# 	# ast.outline

# 	simplify = (node) -> {
# 		label: node.type
# 		children: [{label: "#key = #value"} for key, value of node.properties ? {}] ++ [simplify child for child in node?links?children?list ? []]
# 		node.outline
# 	}
# 	# TODO When an array has only one element, remove the array
# 	debug = (node) -> {(node.label): [debug .. for node.children ? []]}
# 	# TODO Sort nodes to put nodes with children at bottom

# 	ast = simplify ast
# 	if options.debug => ast = debug ast

# 	return ast




outline = (ast) ->
	simplifyTree = (node) ->
		switch typeof! node
		| 'Object' => for key, value of node
			processed = simplifyTree value
			switch typeof! processed
			| 'String' => {label: "#{key}: #value", children: []}
			| 'Array' => {label: "#key", children: processed}
			| _ => throw 'Unexpected returned value'

		| 'Array' => for value, index in node
			processed = simplifyTree value
			switch typeof! processed
			| 'String' => {label: "#{index}: #value", children: []}
			| 'Array' => {label: "#index", children: processed}
			| _ => throw 'Unexpected returned value'

		| _ => "#node"

	{ast: simplifyTree ast}



exports <<< {
	outline
}
