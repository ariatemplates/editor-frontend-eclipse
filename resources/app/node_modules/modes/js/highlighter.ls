require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
}



rangeToLoc = -> {start: it.0, end: it.1}

/**
 * Returns a list of ranges associated to a style.
 */
highlight = (ast) ->
	{tokens ? [], comments ? []} = ast

	tokens = [{style: token.type} <<< rangeToLoc token.range for token in tokens]
	comments = [{style: 'Comment'} <<< rangeToLoc comment.range for comment in comments]

	{highlights: _.sortBy (tokens ++ comments), (.start)}



tokenize = (ast, {source, index}) ->
		index ?= 0
		{tokens ? [], comments ? []} = ast

		# Creates our custom token format from what we got
		tokens = [{token.type} <<< rangeToLoc token.range for token in tokens]
		comments = [{type: 'Comment'} <<< rangeToLoc comment.range for comment in comments]

		# Sorts tokens by position, since merging tokens and comments introduces disorder
		tokens = _.sortBy (tokens ++ comments), (.start)


		# Adds missing whitespaces
		finalTokens = []
		lastToken = {end: 0}
		for token in tokens
			if token.start > lastToken.end
				finalTokens.push {type: 'ws', start: lastToken.end, end: token.start}
			finalTokens.push token
			lastToken = token
		lastToken = finalTokens[*-1]
		if lastToken.end < source.length
			finalTokens.push {type: 'ws' start: lastToken.end, end: source.length}

		tokens = finalTokens

		# Applies offset
		for token in tokens
			token.start += index
			token.end += index

		# Return
		{tokens}


exports <<< {
	highlight
	tokenize
}
