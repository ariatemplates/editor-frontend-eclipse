var prelude = require('prelude-ls');

var oop = require('oop');

var Parser = require('./pegjs-parser/parser').Parser;



var Code = oop.class({
	name: 'Code',

	desc: 'Model for a source code. Kind of equivalent (but more specific) to the Document model in Eclipse.',

	// schema: {
	// 	properties: [
	// 		{names: ['parser'], type: Parser, required: true},
	// 		{names: ['input']}
	// 	]
	// },

	constructor: function(parser, input) {
		this.parser = parser;

		this.source = '';
		this.graph = undefined;

		if (input != null) {
			this.update(input);
		}
	},

	methods: {
		/**
		 * WARNING: Be careful of being efficient in this method, it is critical as this is the one called the most often!
		 *
		 * @todo? be able to specify a length property (computing end or start)
		 * @todo? be able to specify a unique end property for insertion (like it does for now with unique start)
		 * @todo be able to specify a pos property, for insertion, less confusing that the unique start or end property
		 */
		update: {
			desc: 'Updates the models of the code given a diff description in the source code.',

			chainable: true,

			input: {
				inputToSpec: {
					'String': 'text'
				},
				properties: [
					{
						names: ['text', 'source', 'src', 'content'],
						desc: 'The new text to set.',
						default: '',
						type: oop.types.String
					},
					{
						names: ['start', 'beginning', 'offset', 'index'],
						desc: 'INCLUSIVE. The start index relative to the current code from which the given text will be set.',
						default: function() {return this.source.length;}, // appended text by default
						type: oop.types.Number
					},
					{
						names: ['end', 'stop'],
						desc: 'INCLUSIVE. The end index relative to the current code until which the given text will be set.',
						// inferred: 'start'
						type: oop.types.Number
					},
					{
						names: ['replace', 'erase', 'swap'],
						desc: 'A flag to ignore offsets and replace the entire current text with the given one.',
						default: false,
						type: oop.types.Boolean
					},
				]
			},

			exec: function(spec) {
				if (spec.replace) {
					this.source = spec.text;
					this.graph = this.parser.parse(this.source);
				} else {
					if (spec.end == null) {
						spec.end = spec.start;
					}

					this.source =
						this.source.substring(0, spec.start) +
						spec.text +
						this.source.substring(spec.end + 1, this.source.length);

					this.graph = this.parser.parse(this.source);
				}
			}
		}
	}
})



exports.Code = Code;
