require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
}



class Node

	############################################################################
	# Construction
	############################################################################

	/**
	 * @param[in] language {String|Null|Any} The language to which this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the language is unknown, or non-relevant for now.
	 *
	 * @param[in] element {String|Null|Any} The type of the element for the language this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the type is unknown, or non-relevant for now.
	 *
	 * @param[in] line {Number} The number of the line where the element starts.
	 *
	 * @param[in] column {Number} The number of the column where the element starts.
	 *
	 * @param[in] index {Number} The number of the character - 0-based index of the total input - where the element starts.
	 */
	(language, element, line, column, index, end) ~> @ <<< {
		type: {
			language
			element
		}
		location: {
			start: {
				line
				column
				index
			}
			end
		}
	} <<< {
		properties: {}
		children: []
		childrenIndex: {}
	}# <<< {
	# 	links:
	# 		children: []
	# 		childrenIndex: {}
	# 		parents: []
	# }



	############################################################################
	# Children management
	############################################################################

	/**
	 * Adds a child to the children list.
	 */
	_pushChild: (id, child) -> child
		.._index = @children.length
		.._parentId = id;
		..parent = @
		@children.push ..

	/**
	 *  Adds a child node with the given id.
	 */
	add: (id, child) ->
		@_pushChild id, child
		@{}childrenIndex[id] = child

	/**
	 * Adds a list of children nodes with the given id.
	 *
	 * These children are concatenated to the internal list of childrren, and each of them receives an the id along with an index property, 0-based indexed from the given list.
	 *
	 * The list is directly added under the given id to the children index.
	 */
	addList: (id, list) ->
		for child, index in list
			@_pushChild id, child
			child._parentIndex = index
		@{}childrenIndex[id] = list



	############################################################################
	# Properties management
	############################################################################

	set: (key, value) -> @properties[key] = value
	get: (key) -> @properties[key]

	############################################################################
	# _Put factory_
	#
	# DISCLAIMER Experimental: might not work in all cases, especially with empty arrays.
	############################################################################

	/**
	 * A kind of _factory_ for the three methods `add`, `addList` and `set`.
	 *
	 * However, using the other methods brings some advantages:
	 * - more efficient
	 * - helps keeps the client code clean, as you will know be reading it what kind of element you are adding
	 *
	 * But if you want to have a unified method to add everything, use this one.
	 */
	put: (key, value) ->
		# This is a single node
		if value instanceof @@
			@add key, value
		else
			# This is not a node, and can't be a list of nodes, so it's a property
			if typeof! value isnt 'Array'
				@set key, value
			else
				if not _.isEmpty value # FIXME For now empty arrays are simply dropped
					# This is a list of nodes
					if value.0 instanceof @@
						@addList key, value
					# This is a list without node, so it's considered as a property
					else
						@set key, value



	############################################################################
	# Traversing
	############################################################################

	/**
	 * This is a node/parent-first traversing.
	 *
	 * @todo Bring here the implementation from my own framework (ymeine).
	 */
	traverse: (cb) ->
		cb @
		for child in @children => child.traverse cb



	############################################################################
	# Views (on data)
	############################################################################

	flat:~ ->
		result = []
		@traverse -> result.push it
		result



	############################################################################
	# Logging/debug/introspection
	############################################################################

	/**
	 * Simplifies the graph structure (each object's structure).
	 *
	 * # Id
	 *
	 * - key: `id`
	 * - optional: yes, but makes sense only for the root node
	 * - format: depending on the existence of each of the two properties, gives either:
	 * 	- <id>
	 * 	- <id>.<index>
	 * 	- <index>
	 *  - nothing
	 *
	 * # Type
	 *
	 * - key: `type`
	 * - format: <language>.<element>
	 *
	 * # Location
	 *
	 * - remark: start location only for now
	 * - key: `loc`
	 * - format: L<line> C<column> (<index>)
	 *
	 * # Properties
	 *
	 * - key: `props`
	 * - optional: yes
	 * - output: not touched
	 *
	 * # Children
	 *
	 * - key: `children`
	 * - optional: yes
	 * - output: list of simplified children
	 */
	simplify: ->
		{language, element} = @type
		{line, column, index} = @location.start

		join = (sep, part1, part2) -> (_.filter([part1, part2], (?)).join sep) || void
		id = join ' - ' @_index, join '.' @_parentId, @_parentIndex

		{}
			..id? = id
			.. <<< {
				type: if not language? or not element? => null else [language, element] * '.'
				# loc: "L#line C#column (#index)"
				loc: "#{line}x#{column}-#index"
			}
			..props? = @properties
			..children? = if @children.length is 0 => void else [child.simplify! for child in @children]

	/**
	 * Builds a simple tree.
	 *
	 * This internally uses the simplified representation, and this documentation uses this model.
	 *
	 * Each node has the following format:
	 * {
	 * 	<type> (<loc>): list of children converted to simple trees
	 * }
	 *
	 * @recursive
	 * @return A node converted to a simple tree
	 *
	 * @see simplify
	 */
	simpleTree: ->
		simplified = @simplify!
		{
			"#{simplified.id ? 'root'}: #{simplified.type} (#{simplified.loc}) [#{["#key=#value" for key, value of simplified.props ? {}] * ', '}]": [child.simpleTree! for child in @children]
		}





exports <<< {
	Node
}
