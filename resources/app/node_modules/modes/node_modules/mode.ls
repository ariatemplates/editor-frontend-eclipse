require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
# -------------------------------------------------------------------------- STD
	'std/opt/session'
# -------------------------------------------------------------------------- App
	'./code'
}
# ------------------------------------------------------------------ Extractions
{SessionManager} = session
{Code} = code



class Mode
	(input) ~>
		spec = input

		# parser ---------------------------------------------------------------

		{parser} = spec
		if typeof! parser?parse isnt 'Function' => throw {
			msg: 'Invalid given parser'
			parser
		}
		@ <<< {parser}

		# stylesheet -----------------------------------------------------------
		# TODO A stylesheet provider. For now, take it static.


		# Internals ------------------------------------------------------------

		@ <<< {
			sessions: SessionManager!
		}

	############################################################################
	# Session
	############################################################################

	init: ->
		data = new Code!
		id = @sessions.init data
		{guid: id}

	sessionMethod = (method, input) -->
		{guid, id, key} = input
		guid? ?= id
		guid? ?= key

		if not guid? => throw {
			msg: 'No GUID given'
		}

		data = @sessions.get guid

		if not data? => throw {
			msg: 'Invalid GUID (no data)'
			guid
		}

		method data, input



	############################################################################
	# Model
	############################################################################

	update: sessionMethod (code, input) -> code.update input



	############################################################################
	# Parse
	############################################################################

	/**
	 * Generates an AST.
	 */
	_parse: ({source, rule}) -> @parser.parse source, rule

	clean-graph = (node) ->
		delete node.parent
		delete node.childrenIndex

		for child in node.children ? [] => clean-graph child
		node

	/**
	 * Returns an AST.
	 *
	 * It removes circular links so that it can be serialized to be sent.
	 */
	parse: -> @_parse ... |> clean-graph


	############################################################################
	# Highlight
	# FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do hot changes)
	# TODO Be able to provide a default stylesheet, common for all modes? Tis would require to have the same token names...
	############################################################################

	stylesheet: -> ...


	############################################################################
	# Outline
	############################################################################

	/**
	 * @fixme Without the `return` keyword it doesn't work, seems like altering the class itself. LiveScript issue (simmilar as the one for ::member = ...)
	 */
	outline-node = (node) ->
		return {
			label: "#{node._parentId || 'root'}: #{node.type.element}"
			children: [outline-node child for child in node.children ? []]
		}

	outline-simpleTree = (node) ->
		label = _.keys node .0
		children = node[label]
		return {
			label
			children: [outline-simpleTree child for child in children]
		}

	/**
	 * @fixme Why in the "specs" do I require a list of elements, while this will always be a single node (the root)?
	 */
	outline: ({source}:arg) ->
		{ast: [outline-simpleTree (@_parse arg).simpleTree!]}
		# {ast: [outline-node @_parse arg]}



exports <<< {
	Mode
}
