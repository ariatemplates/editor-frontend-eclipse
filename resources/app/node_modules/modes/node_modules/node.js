var Class = require('oop').Class;



var Node = Class({

	name: 'Node',

	/***************************************************************************
	 * Construction
	 **************************************************************************/

	/**
	 * @param[in] language {String|Null|Any} The language to which this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the language is unknown, or non-relevant for now.
	 *
	 * @param[in] element {String|Null|Any} The type of the element for the language this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the type is unknown, or non-relevant for now.
	 *
	 * @param[in] line {Number} The number of the line where the element starts.
	 *
	 * @param[in] column {Number} The number of the column where the element starts.
	 *
	 * @param[in] index {Number} The number of the character - 0-based index of the total input - where the element starts.
	 */
	constructor: function(language, element, line, column, index, end) {
		this.type = {
			language: language,
			element: element
		};
		this.location = {
			start: {
				line: line,
				column: column,
				index: index
			},
			end: end
		};
		this.properties = {};
		this.children = [];
		this.childrenIndex = {};
	},

	prototype: {

		/***********************************************************************
		 * Children management
		 **********************************************************************/

		/**
		 * Adds a child to the children list.
		 */
		_pushChild: function(id, child) {
			child._index = this.children.length;
			child._parentId = id;
			child.parent = this;
			this.children.push(child);
		},

		/**
		 *  Adds a child node with the given id.
		 */
		add: function(id, child) {
			this._pushChild(id, child);
			this.childrenIndex[id] = child;
			return child;
		},

		/**
		 * Adds a list of children nodes with the given id.
		 *
		 * These children are concatenated to the internal list of childrren, and each of them receives an the id along with an index property, 0-based indexed from the given list.
		 *
		 * The list is directly added under the given id to the children index.
		 */
		addList: function(id, list) {
			for (var index = 0, length = list.length; index < length; index++) {
				var child = list[index];
				this._pushChild(id, child);
				child._parentIndex = index;
			}
			this.childrenIndex[id] = list;

			return list;
		},

		/***********************************************************************
		 * Properties management
		 **********************************************************************/

		set: function(key, value) {
			this.properties[key] = value;
			return value;
		},

		get: function(key) {
			return this.properties[key];
		},

		/***********************************************************************
		 * Traversing
		 **********************************************************************/

		/**
		 * This is a node/parent-first traversing.
		 *
		 * @todo Bring here the implementation from my own framework (ymeine).
		 */
		traverse: function(cb) {
			cb(this);

			var children = this.children;
			for (var i = 0, length = children.length; i < length; i++) {
				children[i].traverse(cb);
			}
		},

		/**
		 * Picks up node matching the given predicate by traversing the graph.
		 */
		pick: function(predicate) {
			var list = [];
			var cb = function(node) {
				if (predicate(node)) {
					list.push(node);
				}
			}

			this.traverse(cb);

			return list;
		},

		/***********************************************************************
		 * Views (on data)
		 **********************************************************************/

		flatten: function() {
			return this.pick(function() {return true;});
		},

		leaves: function() {
			return this.pick(function(node) {
				return (node.children == null || node.children.length === 0);
			});
		},

		/***********************************************************************
		 * Logging/debug/introspection
		 **********************************************************************/

		/**
		 * Simplifies the graph structure (each object's structure).
		 *
		 * # Id
		 *
		 * - key: `id`
		 * - optional: yes, but makes sense only for the root node
		 * - format: depending on the existence of each of the two properties, gives either:
		 * 	- <id>
		 * 	- <id>.<index>
		 * 	- <index>
		 *  - nothing
		 *
		 * # Type
		 *
		 * - key: `type`
		 * - format: <language>.<element>
		 *
		 * # Location
		 *
		 * - remark: start location only for now
		 * - key: `loc`
		 * - format: L<line> C<column> (<index>)
		 *
		 * # Properties
		 *
		 * - key: `props`
		 * - optional: yes
		 * - output: not touched
		 *
		 * # Children
		 *
		 * - key: `children`
		 * - optional: yes
		 * - output: list of simplified children
		 */
		simplify: function() {
			/* Attributes */

			var language = this.type.language;
			var element = this.type.element;
			var line = this.location.start.line;
			var column = this.location.start.column;
			var index = this.location.start.index;

			/* id */
			var idParentPart = join(this._parentId, '.', this._parentIndex);
			var id = join(this._index, ' - ', idParentPart);

			/* type */
			var type = language == null || element == null ? null : language + "." + element;

			/* location */
			/* loc = "L#line C#column (#index)" */
			var loc = line + "x" + column + "-" + index;

			/* children */
			var children;
			if (this.children.length !== 0) {
				children = [];
				for (var i = 0, length = this.children.length; i < length; ++i) {
					children.push(this.children[i].simplify());
				}
			}

			/* Output */
			var output = {};

			if (id != null) {
				output.id = id;
			}

			output.type = type;
			output.loc = loc;

			if (this.properties != null) {
				output.props = this.properties;
			}

			if (children != null) {
				output.children = children;
			}

			return output;
		},

		/**
		 * Builds a simple tree.
		 *
		 * This internally uses the simplified representation, and this documentation uses this model.
		 *
		 * Each node has the following format:
		 * {
		 * 	"<id | 'root'>: <type> (<loc>) [<properties>]": list of children converted to simple trees
		 * }
		 *
		 * @recursive
		 * @return A node converted to a simple tree
		 *
		 * @see simplify
		 */
		simpleTree: function() {
			/* Properties computation */

			var simplified = this.simplify();
			var id = simplified.id != null ? simplified.id : 'root';
			var type = simplified.type;
			var loc = simplified.loc;
			var props = simplified.props != null ? simplified.props : {};


			var properties = [];
			for (var key in props) {
				properties.push(key + "=" + props[key]);
			}
			properties = properties.join(', ');

			/* Object creation */

			key = id + ": " + type + " (" + loc + ") [" + properties + "]";

			var value = [];
			for (var i = 0, length = this.children.length; i < length; i++) {
				value.push(this.children[i].simpleTree());
			}

			var output = {};
			output[key] = value;
			return output;
		}
	}
});



function join(part1, sep, part2) {
	if (part1 == null && part2 == null) {
		return;
	}
	if (part1 && part2 == null) {
		return part1;
	}
	if (part2 && part1 == null) {
		return part2;
	}
	return [part1, part2].join(sep);
}



exports.Node = Node;
