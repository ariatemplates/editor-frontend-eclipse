var prelude = require('prelude-ls');

var oop = require('oop');

var SessionManager = require('./session').SessionManager;
var Code = require('./code').Code;



function getOptions(input) {
	return oop.extractProperty(input, {names: ["options", "opts"]}) || {};
}


var Mode = oop.Class({
	name: 'Mode',

	constructor: function(input) {
		oop.processProperties(this, input, {
			properties: [
				{
					names: ['parser']
					// validate: function(parser) {
					// 	if typeof parser?parse isnt 'function' => throw {
					// 		msg: 'Invalid given parser'
					// 		parser
					// 	}
					// }
				},
				{names: ['stylesheetInstance', 'stylesheet']},
				{names: ['highlightedNodes']},
				{names: ['outlineRules', 'outline']}
			]
		});

		if (this.parser == null || !(prelude.isType('Function', this.parser.parse))) {
			throw {
				msg: 'Invalid given parser',
				parser: this.parser
			};
		}

		this.sessions = new SessionManager();
	},



	prototype: {

		/***********************************************************************
		 * Session management
		 **********************************************************************/

		/**
		 * Inits a new session.
		 *
		 * A session is used to manage an instance of a source code on the client side: basically a whole program, a file.
		 *
		 * @todo Maybe allow to pass initial data, like the source
		 */
		init: function(input) {
			var data = {
				code: new Code(this.parser, input)
			};

			var id = this.sessions.init(data);

			return {
				guid: id
			};
		},

		getSessionData: function(input) {
			var guid = oop.extractProperty(input, {names: ['guid', 'id', 'key']});

			if (guid == null) {
				throw {
					msg: 'No GUID given'
				};
			}

			/* Data retrieval ----------------------------------------------- */

			var data = this.sessions.get(guid);

			if (data == null) {
				throw {
					msg: 'Invalid GUID (no data)',
					guid: guid
				};
			}

			return data;
		},



		/***********************************************************************
		 * Model
		 **********************************************************************/

		update: function(input) {
			code = this.getSessionData(input).code.update(input);
		},



		/***********************************************************************
		 * Parse
		 **********************************************************************/

		/**
		 * Generates a code graph.
		 *
		 * This is intended to be used by other services.
		 */
		_parse: function(input) {
			var spec = oop.applyProperties({}, input, [
				{names: ['source']},
				{names: ['options', 'opts', 'opt']}
			]);

			// The following is done to avoid PEG.js generated parsers to be confused with undefined arguments.
			// Indeed if the second argument is passed anyway (to avoid the following hack), but is undefined, the lengths of the arguments will still be 2 instead of 1. This makes the generated parser think there is an option argument
			var args = [spec.source];
			if (spec.rule != null) {
				args.push(spec.options);
			}
			return this.parser.parse.apply(this.parser, args);
		},

		/**
		 * Cleans the graph to prepare it for JSON serialization.
		 *
		 * It basically removes circular links.
		 */
		cleanGraph: function(node) {
			delete node.parent;
			// delete node.childrenIndex;

			var children = node.children != null ? node.children : [];

			for (var i = 0, length = children.length; i < length; i++) {
				this.cleanGraph(children[i]);
			}

			return node;
		},

		/**
		 * Service: returns an AST.
		 */
		parse: function(input) {
			return this.cleanGraph(this._parse(input));
		},



		/***********************************************************************
		 * Highlight
		 *
		 * FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)
		 * XXX Be able to provide a default stylesheet, common for all modes? This would require to have the same token names...
		 **********************************************************************/

		stylesheet: function() {
			return this.stylesheetInstance;
		},

		highlight: function(input) {
			var graph = this.getSessionData(input).code.graph;
			var highlightedNodes = this.highlightedNodes;
			var tokens = graph.pick(function(node) {
				return highlightedNodes.indexOf(node.type.element) !== -1;
			});

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end.index,
					style: token.type.element
				};
			}, tokens);

			// TODO Split ranges as explained in the doc of the highlight submodule
			// Algorithm:
			// While parsing the list of tokens, always store the higher number you found for the end position, along with a reference to the corresponding node
			// This way, for any encountered token, you will immediately be able to tell if it's contained inside another node or not, and to find this node
			// Always apply a split with two nodes only: the highest end position should remain the same, but not necessarily the corresponding node. Note that this split operation can generate two or three nodes, depending on the configuration.
			// THIS DOESN'T WORK: after a split, nothing prevents from having a future node being inside a node which hasn't the highest end offset (imagine a reversed pyramid). Maybe it would be anough to manage with references to the two or three nodes resulting from a split. But with consecutive splits, I don't know if this is still correct.
			// Then I don't know what would be the state about the order of the tokens, maybe a full sort should be applied.

			return {
				ranges: ranges
			};
		},



		/***********************************************************************
		 * Outline
		 **********************************************************************/

		outlineNode: function(node) {
			var id = node._parentId || 'root';
			var type = node.type.element;
			var label = id + ": " + type;


			var children = node.children != null ? node.children : [];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineNode(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		outlineSimpleTree: function(node) {
			var label = Object.keys(node)[0];
			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineSimpleTree(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		/**
		 * @fixme Why in the "specs" do I require a list of elements, while this will always be a single node (the root)?
		 */
		outline: function(input) {
			return {
				ast: [this.outlineSimpleTree(this._parse(arg).simpleTree())]
				// ast: [this.outline-node(this._parse(arg))]
			};
		}
	}
});



exports.Mode = Mode;
