var prelude = require('prelude-ls');

var oop = require('oop');

var Code = require('./code').Code;



function getOptions(input) {
	return oop.extractProperty(input, {names: ["options", "opts"]}) || {};
}


var Mode = oop.Class({
	name: 'Mode',

	constructor: function(input) {
		oop.processProperties(this, input, {
			properties: [
				{
					names: ['parser']
					// validate: function(parser) {
					// 	if typeof parser?parse isnt 'function' => throw {
					// 		msg: 'Invalid given parser'
					// 		parser
					// 	}
					// }
				},
				{names: ['_stylesheet', 'stylesheet']},
				{names: ['highlightedNodes']},
				{names: ['outlineRules', 'outline']}
			]
		});

		if (this.parser == null || !(prelude.isType('Function', this.parser.parse))) {
			throw {
				msg: 'Invalid given parser',
				parser: this.parser
			};
		}
	},



	prototype: {
		/***********************************************************************
		 * Init
		 **********************************************************************/

		/**
		 * Creates a code instance using this mode from the given source.
		 */
		create: function(source) {
			return new Code(this.parser, source);
		},


		/***********************************************************************
		 * Model
		 **********************************************************************/

		/**
		 * Updates the code models.
		 */
		update: function(code, input) {
			code.update(input);
		},



		/***********************************************************************
		 * Parse
		 **********************************************************************/

		/**
		 * Returns an AST.
		 */
		parse: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			return this._cleanGraph(graph);
		},

		/**
		 * Cleans the graph to prepare it for JSON serialization.
		 *
		 * Basically it removes circular links.
		 */
		_cleanGraph: function(node) {
			delete node.parent;

			var children = node.children != null ? node.children : [];

			for (var i = 0, length = children.length; i < length; i++) {
				this._cleanGraph(children[i]);
			}

			return node;
		},



		/***********************************************************************
		 * Highlight
		 *
		 * FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)
		 * XXX Be able to provide a default stylesheet, common for all modes? This would require to have the same token names...
		 **********************************************************************/

		/**
		 * Returns the stylesheet used by this mode.
		 */
		stylesheet: function(code, input) {
			return this._stylesheet;
		},

		highlight: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			var highlightedNodes = this.highlightedNodes;
			var tokens = graph.pick(function(node) {
				return highlightedNodes.indexOf(node.type.element) !== -1;
			});

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end.index,
					style: token.type.element
				};
			}, tokens);

			// TODO Split ranges as explained in the doc of the highlight submodule
			// Algorithm:
			// While parsing the list of tokens, always store the higher number you found for the end position, along with a reference to the corresponding node
			// This way, for any encountered token, you will immediately be able to tell if it's contained inside another node or not, and to find this node
			// Always apply a split with two nodes only: the highest end position should remain the same, but not necessarily the corresponding node. Note that this split operation can generate two or three nodes, depending on the configuration.
			// THIS DOESN'T WORK: after a split, nothing prevents from having a future node being inside a node which hasn't the highest end offset (imagine a reversed pyramid). Maybe it would be anough to manage with references to the two or three nodes resulting from a split. But with consecutive splits, I don't know if this is still correct.
			// Then I don't know what would be the state about the order of the tokens, maybe a full sort should be applied.

			return {
				ranges: ranges
			};
		},

		/***********************************************************************
		 * Outline
		 **********************************************************************/

		/**
		 * @fixme Why in the "specs" do I require a list of elements, while this will always be a single node (the root)?
		 */
		outline: function(code, input) {
			var type = oop.extractProperty(input, {names: ['type']});

			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var outline;
			if (type === "simpleTree") {
				outline = this._outlineSimpleTree(graph.simpleTree());
			} else {
				outline = this._outline-node(graph);
			}

			return {
				ast: [outline]
			};
		},

		_outlineNode: function(node) {
			var id = node._parentId || 'root';
			var type = node.type.element;
			var label = id + ": " + type;


			var children = node.children != null ? node.children : [];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineNode(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		_outlineSimpleTree: function(node) {
			var label = Object.keys(node)[0];
			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineSimpleTree(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		/***********************************************************************
		 * Graph visualization: for client-side
		 **********************************************************************/

		/**
		 * Returns analysis data about the graph representing the code, plus data to use for visual display of it.
		 */
		graph: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var options = getOptions(input);

			var library = options.library || "cytoscape";

			var graphDisplay = this._graphBuilder[library](graph);

			return {
				leaves: graph.leaves().length,
				nodes: graph.flatten().length,
				graph: graphDisplay
			}
		},

		_graphBuilder: {
			/**
			 * Returns a representation of the graph suitable for the JavaScript InfoVis Toolkit library.
			 *
			 * @unimplemented
			 */
			jit: function(graph) {
				throw "Unimplemented";
			},

			/**
			 * Returns a representation of the graph suitable for the Cytoscape.js library.
			 *
			 * The easiest way of using Cytoscape.js is to explicitely specify separately nodes and their connections, that is edges.
			 *
			 * @return An object containing a list of nodes and a list of edges: {nodes, edges}
			 */
			cytoscape: function(graph) {
				var nodes = [];
				var edges = [];

				graph.traverse(function(node) {
					var nodeId = node.getPosition();

					// Node data -----------------------------------------------
					// A new node to go into the list of nodes

					var nodeData = {id: nodeId};

					nodeData.source = node.source;
					nodeData.element = node.type.element;

					var children = node.children.reverse();
					if (children.length === 0) {
						nodeData.name = nodeData.source;
					} else {
						nodeData.name = nodeData.element;
					}
					nodes.push({data: nodeData});

					// Edges ---------------------------------------------------
					// Connection between this node and its children

					for (var i = 0, length = children.length; i < length; i++) {
						var child = children[i];
						var childId = child.getPosition();
						edges.push({data: {id: nodeId + '-' + childId, source: nodeId, target: childId}});
					}

				});

				return {
					nodes: nodes,
					edges: edges
				}
			}
		}
	}
});



exports.Mode = Mode;
