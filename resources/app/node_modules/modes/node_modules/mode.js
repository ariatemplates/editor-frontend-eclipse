var prelude = require('prelude-ls');

var oop = require('oop');

var SessionManager = require('./session').SessionManager;
var Code = require('./code').Code;


var Mode = oop.Class({
	name: 'Mode',

	constructor: function(input) {
		oop.processProperties(this, input, {
			properties: [
				{
					names: ['parser']
					// validate: function(parser) {
					// 	if typeof parser?parse isnt 'function' => throw {
					// 		msg: 'Invalid given parser'
					// 		parser
					// 	}
					// }
				},
				{names: ['stylesheetInstance', 'stylesheet']},
				{names: ['highlightedNodes']},
				{names: ['outlineRules', 'outline']}
			]
		});

		if (this.parser == null || !(prelude.isType('Function', this.parser.parse))) {
			throw {
				msg: 'Invalid given parser',
				parser: this.parser
			};
		}

		this.sessions = new SessionManager();
	},



	prototype: {

		/***********************************************************************
		 * Session management
		 **********************************************************************/

		/**
		 * Inits a new session.
		 *
		 * A session is used to manage an instance of a source code on the client side: basically a whole program, a file.
		 *
		 * @todo Maybe allow to pass initial data, like the source
		 */
		init: function(input) {
			var data = {
				code: new Code(this.parser, input)
			};

			var id = this.sessions.init(data);

			return {
				guid: id
			};
		},

		getSessionData: function(input) {
			var guid = oop.extractProperty(input, {names: ['guid', 'id', 'key']});

			if (guid == null) {
				throw {
					msg: 'No GUID given'
				};
			}

			/* Data retrieval ----------------------------------------------- */

			var data = this.sessions.get(guid);

			if (data == null) {
				throw {
					msg: 'Invalid GUID (no data)',
					guid: guid
				};
			}

			return data;
		},



		/***********************************************************************
		 * Model
		 **********************************************************************/

		update: function(input) {
			code = this.getSessionData(input).code.update(input);
		},



		/***********************************************************************
		 * Parse
		 **********************************************************************/

		/**
		 * Generates a code graph.
		 *
		 * This is intended to be used by other services.
		 */
		_parse: function(input) {
			var spec = oop.processProperties(input, [
				{names: ['source']}
				{names: ['rule']}
			]);

			return this.parser.parse(spec.source, spec.rule);
		},

		/**
		 * Cleans the graph to prepare it for JSON serialization.
		 *
		 * It basically removes circular links.
		 */
		cleanGraph: function(node) {
			delete node.parent;
			delete node.childrenIndex;

			var children = node.children != null ? node.children : [];

			for (var i = 0, length = children.length; i < length; i++) {
				this.cleanGraph(children[i]);
			}

			return node;
		},

		/**
		 * Service: returns an AST.
		 */
		parse: function(input) {
			return this.cleanGraph(this._parse(input));
		},



		/***********************************************************************
		 * Highlight
		 *
		 * FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)
		 * XXX Be able to provide a default stylesheet, common for all modes? Tis would require to have the same token names...
		 **********************************************************************/

		stylesheet: function() {
			return this.stylesheetInstance;
		},

		highlight: function(input) {
			var graph = this.getSessionData(input).code.graph;
			var highlightedNodes = this.highlightedNodes;
			var tokens = graph.pick(function(node) {
				return highlightedNodes.indexOf(node.type.element) !== -1;
			});

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end,
					style: token.type.element
				};
			}, tokens);

			return {
				ranges: ranges
			};
		},



		/***********************************************************************
		 * Outline
		 **********************************************************************/

		outlineNode: function(node) {
			var id = node._parentId || 'root';
			var type = node.type.element;
			var label = id + ": " + type;


			var children = node.children != null ? node.children : [];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineNode(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		outlineSimpleTree: function(node) {
			var label = Object.keys(node)[0];
			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this.outlineSimpleTree(children[i]));
			}

			return {
				label: label,
				children: outlinedChildren
			};
		},

		/**
		 * @fixme Why in the "specs" do I require a list of elements, while this will always be a single node (the root)?
		 */
		outline: function(input) {
			return {
				ast: [this.outlineSimpleTree(this._parse(arg).simpleTree())]
				// ast: [this.outline-node(this._parse(arg))]
			};
		}
	}
});



exports.Mode = Mode;
