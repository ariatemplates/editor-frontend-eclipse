A module used for highlighting.

# File system layout

* [`README.md`](./README.md): this current file
* [`index.js`](./index.js): entry point of the module, provides highligthing for a mode

# Models

* [`color.js`](./color.js): a color representation, basically RGB
* [`font.js`](./font.js): a font representation
* [`style.js`](./style.js): a style for text presentation
* [`stylesheet.js`](./stylesheet.js): a set of rules to apply styles on some portion of text (related to the model of a source code)

# Versioning

To version: _everything_.

# Documentation

## Highlighting

The _highlighting_ is the process of applying different text presentations on partitions of a text displayed inside a text editor in order to show up the semantic.

Entities implied:

* text, source code
* styling rules

Models representing these entities:

* text: list of token nodes or graph from which this list can be extracted (leaves)
* styling rules: stylesheet

Requirements:

* the token nodes must contain location information
* the token nodes must cover a continous range of text

As usual, there are different ways to represent information, implying more or less processing behind, more or less memory, overhead and so on.

Remember that the actual highlighting will be applied by frontends, which will ask the backend for highligthing information.

The main work of the backend is then to transform models to make them understandable by the frontends.

For efficiency, we must limit the amount of information passed to the frontends.

### Backend

The backend must be able to return a continuous list of ranges with style id information:

* the list of ranges represents the list of token nodes: extract it from the graph if necessary
* the style id must correspond to what is used in the stylesheet: we agreed on unsing the token types

It must also be able to provide a stylesheet. The stylesheet should be provided only once, before any highlighting. However, in case this stylesheet changes it should be able to notify the frontend of a change and to provide it again.

Considering the procedure on frontend side (see below), a good way to notify a stylesheet change is to pass a flag anytime a list of ranges is required by the frontend.

The frontend can configure this behavior at session level.also automatically ask for the entire stylesheet anytime it has changed.

Input:

```
{
	start, // the start of the range for which highlighting is requested
	end // the end of this range
}
```

Output:

```
{
	stylesheet // optional, a boolean telling if the stylesheet changed or not or the new stylesheet itself
	ranges: [
		{
			start // always >= 0
			end // always > start
			style // an id corresponding to an id in the stylesheet
		}
		...
		]
}
```

### Frontend

The frontend must require the stylesheet before applying any highlighting.

It should cache this stylesheet to avoid useless transmission. In case the backend notifies a change of stylesheet while

1. if a graph has been passed, extract its list of leaves
1. for each node of the list find its style from the stylesheet or use the default one (specified in the stylesheet too): the style is referenced by the type specifed in the node
1. from the previous point build a list of ranges (locations)


## Color

A model for a color.

There are different physical models to represent a color: RGB, HSV, ...

Our class implements for now RGB colors and provides:

* construction
* factories

No validation is made for now.

To create a color, either call the constructor or a factory.

Constructor input:

* object:
```
{
	r: 0,
	g: 255,
	b: 1
}
```
* number: a grey scale
* string: the name of a predefined color

Any scale must be comprised between `0` and `255`.

## Font

Format:

```
{
	family: 'name',
	height: 12,
	bold: true,
	strike: false,
	underline: false,
	italic: false,
}
```

Factories:

* String: family
* Number: height
* Boolean: bold

## Style

Format:

```
{
	color,
	background,
	font,

}
```


## Stylesheet

# Contribute

## Backlog

### Highlighted nodes specification

There is a rule than could avoid some boilerplate for the user: any node type set in the stylesheet is necessarily part of the highlighted nodes.

We should automatically extract them.

### Highlighting ranges computation

Sometimes highlighting rules could work with kind of _substraction_.

For instance, a node in range `[0, 20]` could have some style, but one of its child in `[5, 10]` could have a more specific style.

So instead of processing it roughly, which would give the result:
```
[
	{
		start: 0
		end: 20
		style // parent node style
	}
	{
		start: 5
		end: 10
		style // child node style
	}
]
```

We should detect it (e.g. _if a highlighted node has a parent which is itself among highlighted nodes_ ) and _cut it_ like this:
```
	{
		start: 0
		end: 4
		style // parent node style
	}
	{
		start: 5
		end: 10
		style // child node style
	}
	{
		start: 11
		end: 20
		style // parent node style
	}
```

This should be handled.

### API robustness & flexibility

For those who know the LiveScript language, you can have a look at what was implemented (commit [`37ab17a622bff137b79beea30242e6970969e333`](https://github.com/ymeine/editors-tools/tree/37ab17a622bff137b79beea30242e6970969e333)).

* enable different input formats:
	* Color
		* `{red, green, blue}`, ...
		* flexible scales (doubles, larger ranges)

### Model

* Color
	* accept HSV format
	* add conversion methods (maybe use a third-party) module
