var oop = require('oop');





var RangeLimit = oop.Class({
	name: 'Range Limit',

	desc: 'A range limit represents the value of either the start or the end of the range. It has more information than a simple number value.',

	schema: {
		inputToSpec: {
			'Number': 'value',
			'String': 'value',
			'Boolean': 'inclusive',
			'Array': function(args) {
				return {
					value: args[0],
					inclusive: args[1],
					direction: args[2]
				}
			}
		},
		properties: [
			{names: ['value', 'val', 'number', 'nb'], type: oop.types.Number, default: 0},
			{names: ['inclusive', 'incl', 'include'], type: oop.types.Boolean, default: true},
			{names: ['direction', 'dir'], type: oop.types.String, default: 'up'}
			// {names: ['direction', 'dir'], type: oop.types.Enum(oop.types.String, ['up', 'down']), default: 'up'}
		]
	},

	properties: {
		'exclusive': {
			get: function() {return !this.inclusive},
			set: function(exclusive) {this.inclusive = !exclusive}
		}
	},

	factories: {
		'nb_bool': {args: {'value': 0, 'inclusive': 1}},
		'bool_nb': {args: {'inclusive': 0, 'value': 1}}
	},

	proto: {
		serialize: function() {
			return this.value + (this.inclusive ? '' : this.direction == 'up' ? '+' : '-');
		},

		eq: function(other) {
			other = RangeLimit.factory(other);

			return (this.inclusive && other.inclusive || (this.inclusive == other.inclusive && this.direction == other.direction)) && this.value == other.value;
		},

		inf: function(other) {
			other = RangeLimit.factory(other);

			if (this.value == other.value) {
				if (this.direction == other.direction) {
					// ~ 5 = 5, 5- = 5-, 5+ = 5+
					if (this.inclusive == other.inclusive) {
						// Equal
						return false;
					}

					// |-> inf ]-> ~ 5 < 5+
					if (this.direction == 'up') {
						return this.inclusive;
					}
					// <-[ in <-| ~ 5- < 5
					if (this.direction == 'down') {
						return this.exclusive;
					}
				}

				// this: |->
				// other: <-|
				if (this.direction == 'up') {
					return false;
				}

				// this: <-[, <-|
				// other: |->, ]->
				if (this.direction == 'down') {
					return other.exclusive || this.exclusive;
				}
			}

			return this.value < other.value;
		},
		sup: function(other) {
			return !this.eq(other) && !this.inf(other);
		},

		infOrEq: function(other) {return this.eq(other) || this.inf(other);},
		supOrEq: function(other) {return this.eq(other) || this.sup(other);}
	},

	statics: {
		// TODO Validate input, do some checkings
		parse: function(source) {
			var lastCharacter = source[source.length - 1];

			var value;
			var inclusive;
			var direction;

			if (lastCharacter == '+') {
				value = source.substring(0, source.length - 1);
				inclusive = false;
				direction = 'up';
			} else if (lastCharacter == '-') {
				value = source.substring(0, source.length - 1);
				inclusive = false;
				direction = 'down';
			} else {
				value = source;
				inclusive = true;
			}
			return RangeLimit({
				value: value,
				inclusive: inclusive,
				direction: direction
			});
		}
	}
});


var Range = oop.Class({
	name: 'Range',

	desc: 'A range is an association of two numbers with some constraints: the start is below or equal to the end.',

	schema: {
		inputToSpec: {
			'Number': 'end',
			'String': 'end',
			'Array': function(args) {
				return {
					start: args[0],
					end: args[1]
				}
			}
		},
		properties: [
			{names: ['start', 'beginning', 'begin', 'min', 'first'], type: RangeLimit, default: 0},
			{names: ['end', 'finish', 'stop', 'max', 'last'], type: RangeLimit, default: 0/*, inferred: 'start*/}
		]
	},

	init: function() {
		if (this.end.value < this.start.value) this.end.value = this.start.value;
		this.start.direction = 'up';
		this.end.direction = 'down';

		if (this.start.value == this.end.value) {
			this.start.inclusive = this.end.inclusive = true;
		}
	},

	factories: {
		'range': {args: {'start': 0, 'end': 1}},
		'reversed': {args: {'end': 0, 'start': 1}}
	},

	properties: {
		'size': {
			get: function() {return this.end.value - this.start.value},
			set: function(length) {this.end.value = this.start.value + length}
		}
	},

	proto: {
		serialize: function() {
			var opening = '[';
			var closing = ']';

			if (!this.start.inclusive) opening = ']';
			if (!this.end.inclusive) closing = '[';

			return opening + this.start.value + ', ' + this.end.value + closing;
		},

		/**
		 * Tells if this range is inside the given other range.
		 */
		in: function(other) {
			other = Range.factory(other);

			return this.start.supOrEq(other.start) && this.end.infOrEq(other.end);
		},

		/**
		 * Tells if this range contains the given limit.
		 */
		contains: function(limit) {
			limit = RangeLimit.factory(limit);

			return limit.supOrEq(this.start) && limit.infOrEq(this.end);
		},

		/**
		 * By definition, if the range is inside the other, it won't overlap it.
		 */
		overlaps: function(other) {
			other = Range.factory(other);

			return {
				left: this.start.inf(other.start) && this.end.supOrEq(other.start),
				right: this.end.sup(other.end) && this.start.infOrEq(other.end)
			}

			return {
				left: (this.start.value < other.start.value && this.end.value > other.start.value),
				right: (this.end.value > other.end.value && this.start.value < other.end.value)
			}
		}
	},

	statics: {
		// TODO Handle whitespaces (between brackets), especially after the comma (optional)
		parse: function(source) {
			var startInclusive = source[0] === '[';
			var endInclusive = source[source.length - 1] === ']';

			var numbers = source.substring(1, source.length - 1).split(', ');
			var startValue = numbers[0];
			var endValue = numbers[1];

			return Range({
				start: {
					value: startValue,
					inclusive: startInclusive
				},
				end: {
					value: endValue,
					inclusive: endInclusive
				}
			});
		},
	}
});





exports.Range = Range;
exports.RangeLimit = RangeLimit;
