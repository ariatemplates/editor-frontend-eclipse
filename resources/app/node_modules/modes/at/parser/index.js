var _ = require('lodash');

var Class = require('oop').Class;
var PEGParser = require('pegjs-parser/parser').Parser;

// var js = require('modes/js');
var html = require('modes/html');




var Parser = Class({
	name: 'ATParser',

	parent: PEGParser,

	constructor: function() {
		PEGParser.call(this, require('./grammar'));
	},

	prototype: {
		/**
		 * Parses parts of the model left unparsed.
		 *
		 * These parts are :
		 * - statement parameters, which are most of the time JavaScript expressions, except for a few exceptions like `foreach`
		 * - free text block, which are for now considered to be HTML
		 */
		postProcess: function(graph) {
			// this._parseStatementParam(graph);
			// this._parseFreeText(graph);
			return graph;
		},

		/**
		 * WORK IN PROGRESS
		 *
		 * Parses the parameter part of statements which should have been left unparsed.
		 *
		 * Most of the time this parameter is simple JavaScript, expected to be a full expression or simply a part of it (depending on the template statement).
		 *
		 * For instance with a `var` statement, the parameter is expected to be a JavaScript variable declaration WITHOUT `var`, with or without initialization.
		 *
		 * Sometimes the parameter is not even JavaScript, as for example the speficic case of the `foreach` statement.
		 */
		_parseStatementParam: function(statement) {
			var param = statement.get('param');
			var node = js.parse(param, 'Expression').body[0]; // JS parser uses Mozilla Parser AST format, with the first node always being a root Program, having a list of elements in his body, here there is always only 1 element

			console.log(param);
			console.log(node);
			console.log();
		},

		_parseStatementParams: function(graph){
			var statements = _.filter(graph.flat, function(node){
				var element = node.type.element;
				return element == 'inline' || element == 'opening';
			});

			for (var i = 0, length = statements.length; i < length; i++) {
				this._parseStatementParam(statements[i]);
			}
		},

		/**
		 * WORK IN PROGRESS
		 *
		 * Traverses the graph to find block statements and for each to parse the HTML it contains as a single block.
		 *
		 * For test purposes, now the only thing done is that the result of the parsing is put in a node with the `html` type, appended as the last child of the block.
		 */
		_parseFreeText: function(graph) {
			graph.traverse(function(node) {
				if (node.type.element === 'block') {
					var htmlNodes = _.filter(node.children, function(node) {
						return node.type.element === null;
					});

					var parts = [];
					for (var i = 0, length = htmlNodes.length; i < length; i++) {
						parts.push(htmlNodes[i].properties.value);
					}

					var htmlValue = parts.join('');

					node.add('html', html.parse(htmlValue));
				}
			});
		}
	}
});



module.exports = new Parser();
