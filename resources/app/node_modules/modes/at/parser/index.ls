require! {
# -------------------------------------------------------------------------- 3rd
	_: lodash
# -------------------------------------------------------------------------- App
	'modes/js'
	pegParser: 'pegjs-parser/parser'
# ------------------------------------------------------------------------ Input
	parser: './grammar'
	htmlParser: 'modes/html/parser'
}
# ------------------------------------------------------------------ Extractions

{Parser:PEGParser} = pegParser



class Parser extends PEGParser
	~> super parser

	post-process: (graph) -> # return graph
		@_parse-statement-params graph
		graph

		# graph.traverse (node) -> if node.type.element is 'block'
		# 	htmlNodes = _.filter node.children, (.type.element is null)
		# 	htmlValue = [child.properties.value for child in htmlNodes] * ''
		# 	node.add 'html' htmlParser.parse htmlValue
		# graph

	_parse-statement-params: (graph) ->
		statements = _.filter graph.flat, (.type.element in <[ inline opening ]>)
		for statement in statements => @_parse-statement-param statement

	_parse-statement-param: (statement) ->
		param = statement.get 'param'
		node = js.parse(param, 'Expression').body.0 # JS parser uses Mozilla Parser AST format, with the first node always being a root Program, having a list of elements in his body, here there is always only 1 element
		console.log param
		console.log node
		console.log!



module.exports = Parser!
