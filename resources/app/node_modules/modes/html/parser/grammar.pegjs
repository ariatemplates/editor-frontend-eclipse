// Initializer -----------------------------------------------------------------

{
	var lib = require('pegjs-parser/initializer');

	var instancier = new lib.NodeInstancier('html');
	var Node = function() {return instancier.create.apply(instancier, arguments)};
}



// Grammar ---------------------------------------------------------------------

// ------------------------------------------------------------------------ Root

start = ws0:__ elements:(elementList __)? {
	var node = Node('root', line, column, offset);
	node.addList('spaces.0', ws0);
	if (elements !== "") {
		node.addList('elements', elements[0]);
		node.addList('spaces.1', elements[1]);
	}
	return node;
}

// -------------------------------------------------------------------- Elements

element =
	text
	/ node

// FIXME This rule is used to parse a list of elements contained in a block element (most of the time)
// These elements are a mix of text, node, and comments also.
// However, concerning the comments, they are "eaten" by the "__" rule, whose content is skipped here.
// So concretely if a node contains only text except some contents inside, these comments are ignored because of that.
// Review the design of this rule (should be the same for Aria Templates)
elementList = head:element rest:(__ element)* {
	return lib.listFromSequence(head, rest);
}

// ------------------------------------------------------------------------ Text
// The particularity of the text element, is that it is not delimited as other elements, it's just everything that is not an element. So to detect the end of a text, we need to check if another element starts.

text = content:(!elementStart .)+ {
	var node = Node('text', line, column, offset);
	node.set('value', lib.stringFromGuardedSequence(content));
	return node;
}

elementStart = "<"

// ----------------------------------------------------------------------- Nodes
// WARNING the precedence in alternatives is important!

node =
	cdata
	/ directive
	/ inline
	/ block

// ------------------------------------------------------------------- Directive

directive = "<!" ws0:__ id:id ws1:__ content:(!">" .)* ">" {
	var node = Node('directive', line, column, offset)
	node.addList('spaces.0', ws0);
	node.set('id', id);
	node.addList('spaces.1', ws1);
	node.set('content', lib.stringFromGuardedSequence(content));
	return node;
}

// ---------------------------------------------------------------------- Inline

inline = "<" id:inlineIds ws0:__ attributes:(attributeList __)? slash:("/" __)? ">" {
	var node = Node('inline', line, column, offset);
	node.set('tag', id);
	node.addList('spaces.0', ws0);
	if (attributes !== "") {
		node.addList('attributes', attributes[0]);
		node.addList('spaces.1', attributes[1]);
	}
	if (slash !== "") {
		node.set('slash', true);
		node.addList('spaces.2', slash[1]);
	} else {
		node.set('slash', false);
	}
	return node;
}

inlineIds =
	"br"
	/ "link"
	/ "meta"

// ----------------------------------------------------------------------- CDATA

cdata = "<![CDATA[" content:(!endOfCdata .)* endOfCdata {
	var node = Node('cdata', line, column, offset);
	node.set('content', lib.stringFromGuardedSequence(content));
	return node;
}

endOfCdata = "]]>"

// ----------------------------------------------------------------------- Block

block = open:opening ws0:__ elements:(elementList __)? close:closing {
	var node = Node('block', line, column, offset);
	node.add('openTag', open);
	node.addList('spaces.0', ws0);
	if (elements !== "") {
		node.addList('elements', elements[0]);
		node.addList('spaces.1', elements[1]);
	}
	node.add('closeTag', close);
	return node;
}

opening = "<" id:id ws0:__ attributes:(attributeList __)? ">" {
	var node = Node('opening', line, column, offset);
	node.set('id', id);
	node.addList('spaces.0', ws0);
	if (attributes !== "") {
		node.addList('attributes', attributes[0]);
		node.addList('spaces.1', attributes[1]);
	}
	return node;
}

closing = "</" ws0:__ id:id ws1:__ ">" {
	var node = Node('closing', line, column, offset);
	node.addList('spaces.0', ws0);
	node.set('id', id);
	node.addList('spaces.1', ws1);
	return node;
}

// ------------------------------------------------------------------- Attribute

attribute = key:id value:(__ "=" __ attrvalue)? {
	var node = Node('attribute', line, column, offset);
	node.set('key', key);
	if (value !== "") {
		node.addList('spaces.0', value[0]);
		node.addList('spaces.1', value[2]);
		node.add('value', value[3]);
	}
	return node;
}

// TODO handle white spaces
attributeList = head:attribute rest:(__ attribute)* {
	return lib.listFromSequence(head, rest);
}

attrvalue =
	string
	/ word

// --------------------------------------------------------------------- Strings

string =
	doubleQuoteString
	/ simpleQuoteString

doubleQuoteString = '"' raw:(!'"' .)* '"' {
	var node = Node('string', line, column, offset);
	node.set('quote', '"');
	node.set('value', lib.stringFromGuardedSequence(raw));
	return node;
}

simpleQuoteString = "'" raw:(!"'" .)* "'" {
	var node = Node('string', line, column, offset);
	node.set('quote', "'");
	node.set('value', lib.stringFromGuardedSequence(raw));
	return node;
}

// -------------------------------------------------------------------- Comments

comment = "<!--" content:(!"-->" .)* "-->" {
	var node = Node('comment', line, column, offset);
	node.set('value', lib.stringFromGuardedSequence(content));
	return node;
}

// --------------------------------------------------------------------- Various

__ = elements:(wsSequence / comment)* {
	return elements;
}

// Primitives ------------------------------------------------------------------

// -------------------------------------------------------------------------- ID

id = head:idhead rest:idrest* {return head + rest.join('')}
idhead = idchars
idrest = "-" / digit / idchars
idchars = alpha / idspecial
idspecial = [$_]

// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence =
	spaces
	/ tabs
	/ eol

spaces = content:" "+ {
	var node = Node('spaces', line, column, offset);
	node.set('size', content.length);
	return node;
}

tabs = content:"\t"+ {
	var node = Node('tabs', line, column, offset);
	node.set('size', content.length);
	return node;
}

eol = value:("\r" / "\n" / "\r\n") {
	var node = Node('eol', line, column, offset);
	node.set('value', value);
	return node;
}

// --------------------------------------------------------------------- Various

word = content:(!ws .)* {return lib.stringFromGuardedSequence(content);}

alpha = [a-zA-Z]
digit = [0-9]
