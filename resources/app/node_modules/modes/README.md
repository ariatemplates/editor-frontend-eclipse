_modes_ are modules implementing source code edition services for specific languages.

Modes might use each other.

# File system layout

* [`README.md`](./README.md): this current file
* [`parser.md`](./parser.md): an article about how to create a parser
* [`node_modules`](./node_modules): common resources for modes
* [`editor.js`](./editor.js): the exposed module to use for code edition services
* [`modeManager.js`](./modeManager.js): a module managing modes and documents

__All the other folders not already mentioned are modes, please refer to their respective documentations for more details.__

# Versioning

To version: _everything_.

# Documentation

## Editor

The editor module is the __unique__ entry point for code edition services.

For now, concretely it creates and exports an instance of a mode manager configured properly.

It adds to this manager all the modes already implemented.

## Mode manager

__The name is maybe not the best one. It should be more document (code documents) manager. Maybe split the two, creating a document manager using the mode manager__

The mode manager does two jobs:

* it manages documents, through what we call sessions
* it manages modes, they can be added and are then available for documents

### Modes

You can add modes to the mode manager, giving several names for those modes for more flexibility.

The modes are referenced through those names by documents, and are used to apply actual services on those documents.

### Documents

Documents can be initialized through this module: you need to specify which mode the document will use (among the available modes).

After initialization, a unique id is given for this document. This is mandatory to keep it, because this is what is used to refer to a document.

Then you can call mode services against a document by giving the id of this document and the name of the service, along with proper arguments. So you don't call directly a mode service providing a document, since documents are the center of the design. Instead, documents are linked to modes.

## Parser creation

This section describes the choices made to create parsers when this is needed.

### Requirements

Here are the requirements of the parser:

* generate at least a tree
* keep location information, both as ranges (indexes in the full string of code) and coordinates (line/column model)
* ...

### Choice

As all the points mentionned above involve a strong knowledge of both the language we want to manage and the theory of formal languages, we won't have time to totally proceed like this.

We will refer to a strong power which is the community.

One of the most famous tool to generate parsers in JavaScript is [PEG.js](http://pegjs.majda.cz/). It uses the [parsing expression grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar) model, which is apparently more powerful than other more traditional ones.

# Contribute

## FIXME

### Use the full ID object in the service request

__For consistency, the GUID property in a request should be the full object like `{guid: 0}`.__

Indeed, this would have multiple benefits:

* on the client side, no need anymore to extract the guid value returned from the backend, to pass it again inside a property of a request object for instance
* on the backend side, the mode manager can directly use the definition of the GUID class in the Request class, instead of only using the same property names
* this would give the possibility for the GUID object to evolve easily, with more properties

So this would now give:

```javascript
{
	"module": "editor",
	"method": "exec",
	"argument": {
		"id": { // Whatever an ID returned by the init method is. Could be {filename: "..."}
			"guid": 0
		},
		"svc": "stylesheet"
	}
}
```

instead of:

```json
{
	"module": "editor",
	"method": "exec",
	"argument": {
		"guid": 0,
		"svc": "stylesheet"
	}
}
```

## Development

You can either work on the common library for modes in `node_modules` or on a specific mode.

Please refer to the respective documentations.

## Node ids for outline

__Add node ids to outline nodes and allow _contextual_ requests.__

_See [tickets](/ultimate-poc/src/poc/outline/README.md) in the Eclipse plugin project about outline performances._

For performances issues essentially, we should be able to work with partial parts of the outline model. Whether it is for update, or just data requests.

With a node id, the backend would be able to know with which node it is going to work. That way, the client would be able to request outline data for a given node.

For even more performances, a depth level of the requested subtree could be passed: this way the backend would send only a few nodes, with proper ids, and the client would request their own subtrees if needed, passing the ids.

## Parser creation

Maybe we could consider using [Jison](https://github.com/zaach/jison) to generate the parser. I don't know it fully yet but had an overview of it whil ereading [this article about sourcemaps](https://hacks.mozilla.org/2013/05/compiling-to-javascript-and-debugging-with-source-maps/).

Pros:

* using data instead of a DSL
* separates the lexer and the grammar: automatically generates tokens and forces to use them
* famous

Cons:

* the data is put into strings with weak meaning, I mean that we could also put the PEG.js DSL content into strings. Here, strings are either rules or JavaScript code. It's the same. However, as this is standard JS data, we can add our own layer on it, preprocessing the rules, doing whatever we want.
* I don't know how we would handle parts of free text as we do it now with PEG.

Moreover, I think we can also use data with PEG.js, by _hacking_ it a little. And finally I like the way PEG.js is detached from the usual formalisms, using stringly different models for closely related things: tokens, trees. I just want to build a graph. For everything, almost every character in the code. The distinction between syntax and semantics comes later on for me.

## Documentation

* Put the artcile in `parser.md` about the parser creation process in the wiki
* Write an article more specifically about PEG.js
	* description, links to resources
	* how I use it in the project (how I prefer structuring the grammar, using the initializer, ...)
	* what interesting things I learned about PEG.js (which are not obvious): like the possibility to call a specific rule with the `parse` method
	* which version I use
