var prelude = require('prelude-ls');

var oop = require('./oop');
var helpers = require('./helpers');



/*******************************************************************************
* Property names
*******************************************************************************/

var propertyIds = {
	names: ['names', 'name', 'keys', 'key', 'ids', 'id']
}


// var map = [
// 	{name: 'output', default: {}},
// 	{name: 'input'},
// 	{name: 'rules'}
// ]

// function processArguments(args, rules) {
// 	var output = {};
// 	for (var argPos = 0, length = rules.length; i < length; i++) {
// 		var arg = args[argPos];
// 		var def = rules[argPos].default;
// 		if (arg == null && def != null) {
// 			arg = def;
// 			args.
// 		}
// 	}
// }


function processProperties() {
	var output;
	var input;
	var rules;
	var context;

	if (arguments.length === 4) {
		output = arguments[0];
		input = arguments[1];
		rules = arguments[2];
		context = arguments[3];
	} else if (arguments.length === 3) {
		throw {
			msg: 'Ambiguous arguments',
			arguments: arguments,
			stack: Error().stack
		}
	} else if (arguments.length === 2) {
		input = arguments[0];
		rules = arguments[1];
	} else {
		throw {
			msg: 'Wrong number of arguments',
			arguments: arguments,
			stack: Error().stack
		}
	}

	if (output == null) {output = {};}

	// if (arguments.length < 3) {
	// 	output = {};
	// 	input = arguments[0];
	// 	rules = arguments[1];
	// } else {
	// 	output = arguments[0];
	// 	input = arguments[1];
	// 	rules = arguments[2];
	// }

	var spec = inputToSpec(input, rules.inputToSpec);
	applyProperties(output, spec, rules.properties, context);

	return output;
}

function inputToSpec(input, rules) {
	if (prelude.isType('Object', input)) {
		return input;
	}

	rules == null && (rules = {});
	for (var type in rules) {
		if (prelude.isType(type, input)) {
			var ruleValue = rules[type];

			var handler;
			if (prelude.isType('String', ruleValue)) {
				handler = function(input) {
					var output = {};
					output[ruleValue] = input;
					return output;
				}
			} else if (prelude.isType('Function', ruleValue)) {
				handler = ruleValue;
			} else {
				handler = function() {return {}};
			}

			return handler(input);
		}
	}

	return {};
}

/**
 * Extracts a set of properties from a spec object, thanks to properties specifications, and puts the result in the output object.
 *
 * @see extractProperty
 */
function applyProperties(output, spec, propertiesSpecs, context) {
	for (var key in propertiesSpecs) {
		applyProperty(output, spec, propertiesSpecs[key], context);
	}

	return output;
}

function propertySpecFactory(propertySpec) {
	if (prelude.isType('String', propertySpec)) {
		return {names: [propertySpec]};
	}

	if (prelude.isType('Array', propertySpec)) {
		return {names: propertySpec};
	}

	return propertySpec;
}

/**
 * @todo For now we consider we don't put any explicit undefined or null value in the output. This could be made configurable
 */
function applyProperty(output, spec, propertySpec, context) {
	propertySpec = propertySpecFactory(propertySpec);

	var value = extractProperty(spec, propertySpec, context);

	if (value != null) {
		var name = extractValue(propertySpec, ['output', 'outputName']);

		if (name == null) {
			name = oop.types.Array.factory(extractValue(propertySpec, propertyIds.names))[0];
		}

		if (name != null) {
			output[name] = value;
		}
	}
}

function extractProperty(spec, propertySpec, context) {
	// propertySpec ------------------------------------------------------------

	propertySpec = propertySpecFactory(propertySpec);

	// Extraction --------------------------------------------------------------

	var value = extractValue(spec, extractValue(propertySpec, propertyIds.names));

	// Null - Skips the property -----------------------------------------------
	// Explicit null value will skip the process of inference, applying default value, ...

	if (value === null) return;

	// Constructor -------------------------------------------------------------

	// WARNING Same remark as previous in this file: 'constructor' to be kept at the end
	var constructor = extractValue(propertySpec, ['ctor', 'type', 'factory', 'constructor']);

	if (constructor != null) {
		var factory = constructor.factory;

		if (factory != null) {
			if (value !== undefined) {
				value = factory(value);
			}

			if (value == null && propertySpec.mixed) {
				try {value = factory(spec);} catch (e) {}
			}
		}
	}

	// Default -----------------------------------------------------------------

	if (value === undefined) {
		var def = extractValue(propertySpec, ['default', 'def']);
		if (def != null) {
			if (prelude.isType('Function', def)) {
				// TODO be able to specify context per spec
				// def = def(extractValue(spec, ['context', 'scope']);
				def = def.call(context);
			}

			value = def;
		}
	}

	// Post-process ------------------------------------------------------------

	var postprocess = propertySpec.postprocess;
	if (postprocess != null) {
		value = postprocess(value);
	}

	// Required ----------------------------------------------------------------

	var required = extractValue(propertySpec, ['required', 'req']);
	if (required) {
		if (value == null) {
			throw {
				msg: 'Missing required value',
				property: propertySpec,
				spec: spec
			}
		}
	}

	// Output ------------------------------------------------------------------

	return value;
}

/**
 * Extracts a value from the given object using the given names
 */
function extractValue(input, names) {
	if (names == null) return;
	names = oop.types.Array.factory(names);

	for (var i = 0, length = names.length; i < length; i++) {
		var property = input[names[i]];
		if (property !== undefined) {return property;}
	}
}





exports.processProperties = processProperties;
exports.inputToSpec = inputToSpec;

exports.applyProperties = applyProperties;
exports.applyProperty = applyProperty;

exports.extractProperty = extractProperty;

exports.extractValue = extractValue;

exports.propertyIds = propertyIds;
