___MOVE IT___

This is part of my own ([ymeine](https://github.com/ymeine)) standard library, and here should stand only a copy of the required files (development or production version).

----

A server library, with an _embedded_ JSON-RPC library.

# File system layout

* `README.md`: this current file
* `index.ls`: exports a convenient function to run a server

## Modules

Implementations (see below).

These files return classes.

* `route.ls`: `Route`
* `rpc.ls`: `RPC`
* `server.ls`: `Server`

## Utilities

__REFACTOR__

These files return functions.

* `helpers.ls`: various
* `http.ls`: HTTP
* `network.ls`: network

# Versioning

To version: _everything_.

# Documentation

## Services

### Server

#### Routes

The routes are put in a native JavaScript array exported by the module, and defined as native JavaScript objects.

#### Options

Here are the important properties:

* `network: ports: prefered` - Number: the ports you would like to use to run the server, if available
* `statics`
	* `absolute` - Array of Strings: absolute paths to use as static serving locations
	* `relative` - Array of Strings: relative paths to use as static serving locations
* `log` - Boolean: wether or not to active console logging. Of course this makes sense only if the console is available. The logging system is a work in progress (consider using [winston](https://github.com/flatiron/winston))

#### TODO

* Handle all the possible options, even if optionally passed

### RPC

It acts like a proxy, being able to get properties or call functions from an object.

There is no interface restriction. It is simply a bridge between a network communication and a virtual machine runtime.

#### TODO

* Handle relative paths for modules. It means knowing what was the root path considered when defining the list of modules. I don't see a lot of solutions, from getting the path of the parent module but this can be only an intermediate, to requiring the user to put the specify the root in case he gives relative paths.

## Model

### Route

Here is the format of a route:

* `method`: the HTTP method name (you can use any case you want)
* `url`: the path from the root of the server

Then, you can specify a handler in different ways.

The handler is the function receiving the request and handling the response. Refer to the [zappajs](http://zappajs.github.io/zappajs/) documentation for more details.

Each property will create a specific handler, and they follow precedence rules:

1. `status`: a handler sending this status will be automatically created
1. `view`: a  handling rendering this view will be automatically created
1. `handler`: a custom function

## Utilities

### HTTP

### Helpers

### Network

# Contribute

## Pre-requisites

* Node.js
* LiveScript

# FIXME

* the hardcode module for CoffeeCup views is not imported
* The _helpers_ module file contains only a logging function, used only by the _server_. Try to get rid of that, and use a unique external implementation of logging (I've made more or less 4/5 implementations...)

# References

* [LiveScript](http://livescript.net/)
* [Node.js](http://nodejs.org/)
