require! {
# ---------------------------------------------------------------------- Own STD
	'server/rpc'
}



class Route
	@factory = (input) -> if input instanceof @@ => input else new @@ ...

	(input, logger, server) ~>
		# Factory --------------------------------------------------------------

		spec = switch typeof! input
		| 'String' => {type: input}
		| 'Object' => input
		| _ => {}

		# logger ---------------------------------------------------------------

		@ <<< {logger}

		# server ---------------------------------------------------------------

		@ <<< {server}

		# type -----------------------------------------------------------------

		{type} = spec

		defaults = switch type
		| 'rpc' => {
			method: \post
			url: '/rpc'
			handler: let RPC = new rpc.RPCManager logger
				for mod in spec.modules => RPC.addModule mod
				!-> RPC.exec @
		}
		| 'shutdown'
			url: '/shutdown'
			handler: !->
				msg = 'Exiting backend application.'
				logger.info msg
				@send msg
				process.exit 0
		| 'ping' => {
			log: pre: 'Ping'
			url: '/ping'
			status: 200
		}
		| 'info' => {
			url: '/info'
			status: 501
			# handler: !-> @send server.info!
		}
		| _ => {}

		spec = defaults with spec

		# handler --------------------------------------------------------------
		# XXX This synonymy is not usual, as each term denotes a particular type of data. indeed, a status should be a number. However, if this is a string, this should work too. For that, consider the three properties as different, and 2 of them as being convenient ways to define an handler. It's more or less what I did before.

		{handler, status, view} = spec

		handler? ?= status
		handler? ?= view

		handler = switch typeof! handler
		| 'Number'
			let status = handler => !-> @send status
		| 'String'
			let view = handler => !-> @render (spec.view): {hardcode}
		| 'Function' => handler
		| _ => throw {
			msg: 'No valid handler found or generated'
			spec
		}

		@ <<< {handler}

		# method ---------------------------------------------------------------

		{method} = spec

		method ?= \get

		@ <<< {method}

		# url ------------------------------------------------------------------

		{url} = spec

		url ?= '/'

		@ <<< {url}

		# log ------------------------------------------------------------------

		{log} = spec

		@log ?= log



	register: (type, system) -->
		switch type
		| 'zappa', 'zappajs'
			system[@method.toLowerCase!] {
				(@url): let self = @ => ->
					if self.log?pre? => self.logger.info that
					self.handler ...
					if self.log?post? => self.logger.info that
			}

		| _ => throw {
			msg: 'Unsupported system'
			system: type
		}

	register-zappa: ::register 'zappa'
	register-zappajs: ::register 'zappajs'





exports <<< {
	Route
}
