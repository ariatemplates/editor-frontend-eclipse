// var Class = require('jsclass/src/core').Class;

var prelude = require('prelude-ls');





/*******************************************************************************
* Class
*******************************************************************************/

// Work in progress, to use JSClass behind -------------------------------------
// function klassJSClass(input) {
// 	var spec = input;

// 	var name = spec.name;
// 	var parent = spec.parent;
// 	var constructor = spec.constructor;
// 	var prototype = spec.prototype;

// 	constructor.displayName = name;

// 	var content = {
// 		initialize: constructor
// 	};
// 	for (var member in prototype) {
// 		content[member] = prototype[member];
// 	}

// 	if (parent != null) {
// 		return new Class(parent, content);
// 	} else {
// 		return new Class(content);
// 	}
// }

// Own implementation ----------------------------------------------------------

function klass(input) {
	var spec = input;

	// Instance properties -----------------------------------------------------

	var properties = spec.properties || [];

	// Constructor generation --------------------------------------------------
	// TODO For callable instance: give the user the possibility to specify a name for a prototype function, equal to the `call` function. This way, both `instance()` and `instance.<whatever-name>()` will be possible.

	var ctor = spec.constructor;
	var call = spec.call;
	if (!prelude.isType('Function', call)) {
		// Warning
		call = undefined;
	}

	function constructor() {
		// Allows calling the constructor both with and without the `new` keyword
		var self = this instanceof constructor ? this : {};

		// Calls the actual constructor function (initialization)
		ctor.apply(self, arguments);

		// Defines instance properties
		prelude.each(function(property) {
			prelude.each(function(name) {
				Object.defineProperty(self, name, property.descriptor);
			}, property.names);
		}, properties);

		// Creates a callable instance using the call function provided
		if (call != null) {
			self = call.bind(self);
		}

		return self;
	}

	// Inheritance -------------------------------------------------------------

	var parent = spec.parent;
	if (parent != null) {
		_import(constructor, parent);
		extend(constructor, parent);
	}

	// Identification ----------------------------------------------------------

	var name = spec.name;
	constructor.displayName = name;

	// Prototype ---------------------------------------------------------------

	var prototype = spec.prototype;
	_import(constructor.prototype, prototype)

	// Statics -----------------------------------------------------------------

	var statics = spec.statics;
	addStatics(constructor, statics);

	// Factories ---------------------------------------------------------------

	var factories = spec.factories || {};
	for (var factoryName in factories) {
		addFactory(constructor, factoryName, factories[factoryName]);
	}

	// Automatic factory generation --------------------------------------------

	constructor.factory = function factory(input) {
		if (input == null) {
			return undefined;
		}

		if (input instanceof constructor) {
			return input;
		}

		return new constructor(input);
	};

	// Return ------------------------------------------------------------------

	return constructor;
}

function addStatics(constructor, statics) {
	_import(constructor, statics);
}

function addFactory(constructor, name, spec) {
	constructor[name] = createFactory(constructor, spec);
}

function createFactory(constructor, spec) {
	var argsMap = spec.args || {};
	var valuesMap = spec.values || {};

	return function() {
		var spec = {};

		for (var specProperty in argsMap) {
			var argPosition = argsMap[specProperty];
			spec[specProperty] = arguments[argPosition];
		}

		for (var specProperty in valuesMap) {
			var value = valuesMap[specProperty];
			spec[specProperty] = value;
		}

		return new constructor(spec);
	}
}

/**
 * Extends a constructor from a parent constructor.
 *
 * Extending means setting up the prototype chain: the prototype of the constructor is an object whose prototype itself is the one of the parent.
 *
 * It also sets some properties to access parent features, like:
 * - a link to the parent constructor: `superclass`
 */
function extend(constructor, parent) {
	constructor.superclass = parent;

	function fn() {}
	fn.prototype = parent.prototype;

	constructor.prototype = new fn;
	constructor.prototype.constructor = constructor;

	return constructor;
}





/*******************************************************************************
* Properties
*******************************************************************************/

/**
 * Processes input of constructors of classes used to represent models.
 *
 * The general workfow is this one:
 * - you build an object by sending a value to the constructor
 * - this value can be either a factory, which has to be converted to a spec object
 * - or directly an object
 * - the new object being built takes properties from the spec object, which can have a different form (more flexibe, since this is made _by hand_ by the user)
 *
 * The output is the object being built, the input is any suitable value regarding your rules, and the rules contains both rules to convert the input to a proper spec object and to extract properties from the latter.
 *
 * @see inputToSpec
 * @see applyProperties
 */
function processProperties() {
	var output;
	var input;
	var rules;

	if (arguments.length < 3) {
		output = {};
		input = arguments[0];
		rules = arguments[1];
	} else {
		output = arguments[0];
		input = arguments[1];
		rules = arguments[2];
	}

	var spec = inputToSpec(input, rules.inputToSpec);
	applyProperties(output, spec, rules.properties);

	return output;
}

/**
 * Converts any input value to a spec object (kind of factory), thanks to a set of rules.
 *
 * # Rules
 *
 * Rules for now are simple. For a given type, you can do one of the following:
 * - specify to which property of the output spec object the given input value will go
 * - specify a handler function that will get the input value and must return the spec it builds itself
 *
 * Example: ```
 * 	var rule = {
 * 		'String': 'str',
 * 		'Number': 'nb'
 * 	};
 * 	inputToSpec('a string', rules); // => {str: 'a string'}
 * 	inputToSpec(5, rules); // => {nb: 5}
 * ```
 *
 * There are to default rules:
 * - if the given input is an object, it is considered as being a spec already (no way to determine it is not, except by checking with more semantics, but this is complex and the user would have to give lots of rules - schemas for instance)
 * - if nothings matches, an empty object is returned
 */
function inputToSpec(input, rules) {
	if (prelude.isType('Object', input)) {
		return input;
	}

	rules == null && (rules = {});
	for (var type in rules) {
		if (prelude.isType(type, input)) {
			var ruleValue = rules[type];

			var handler;
			if (prelude.isType('String', ruleValue)) {
				handler = function(input) {
					var output = {};
					output[ruleValue] = input;
					return output;
				}
			} else if (prelude.isType('Function', ruleValue)) {
				handler = ruleValue;
			} else {
				handler = function() {return {}};
			}

			return handler(input);
		}
	}

	return {};
}

/**
 * Extracts a set of properties from a spec object, thanks to properties specifications, and puts the result in the output object.
 *
 * @see extractProperty
 *
 */
function applyProperties(output, spec, propertiesSpecs) {
	for (var key in propertiesSpecs) {
		applyProperty(output, spec, propertiesSpecs[key]);
	}

	return output;
}

/**
 * @todo Be able to specify an explicit name for the property in the output, instead of using the first name in the list of names used for extraction
 */
function applyProperty(output, spec, propertySpec) {
	var value = extractProperty(spec, propertySpec);
	// For now we consider we don't put any explicit undefined or null value in the output
	// TODO this could be made configurable
	value != null && (output[propertySpec.names[0]] = value);
}

/**
 * Extracts a property from a spec object, thanks to a property specifications, and puts the result in the output object.
 *
 * # Property specifications
 *
 * A property has a list of names, that the user can use in the spec.
 *
 * The order of names is important since it has a precedence.
 *
 * The first name of the list is used by default as the name of the property in the output.
 *
 * If no value was defined in the spec for the property, this is not set in the output object (no explicit undefined properties)
 *
 * @fixme When a property is extracted from the given spec, if no suitable property value was found in this spec, the spec itself is used as the property - remember it is just used as input for a factory. For instance, specifying {color: {r, g, b}, font} will work as well as {r, g, b, font} directly. HOWEVER this brings a problem when you want to actually bypass a value, set is as undefined. Take the second object and imagine {r, g, b} were user-specific extra properties, not the spec for the color. Or imagine there is nothing at all for the color ({font}). When trying to build the color property, it should fail. THE USER SHOULD SPECIFY MORE RULES TO HANDLE THIS PROPERLY. For now, the user can specify `null`
 */
function extractProperty(spec, propertySpec) {
	var value;

	// Extraction --------------------------------------------------------------

	var names = propertySpec.names;
	if (names.length === 0) return;

	for (var i = 0, length = names.length; i < length; i++) {
		var property = spec[names[i]];
		if (property !== undefined) {
			value = property;
			break;
		}
	}

	// Null - Skips the property -----------------------------------------------
	// Explicit null value will skip the process of inference, applying default value, ...
	if (value === null) return;

	// Constructor -------------------------------------------------------------

	var constructor = propertySpec.ctor;
	if (constructor != null) {
		factory = constructor.factory;
		value = factory(value);
		if (propertySpec.mixed && value == null) {
			try {value = factory(spec);} catch (e) {}
		}
	}

	// Default -----------------------------------------------------------------

	if (value == null) {
		var def = propertySpec.default;
		if (def != null) {
			value == null && (value = def);
		}
	}

	// Post-process ------------------------------------------------------------

	var postprocess = propertySpec.postprocess;
	if (postprocess != null) {
		value = postprocess(value);
	}

	// Output ------------------------------------------------------------------

	return value;
}





/*******************************************************************************
* Helpers
*******************************************************************************/

function _import(obj, src) {
	var own = {}.hasOwnProperty;

	for (var key in src) {
		if (own.call(src, key)) {
			obj[key] = src[key];
		}
	}

	return obj;
}





/*******************************************************************************
* Export
*******************************************************************************/

module.exports = {
	class: klass,
	Class: klass,
	addStatics: addStatics,

	processProperties: processProperties,
	extractProperty: extractProperty,
	applyProperty: applyProperty,
	applyProperties: applyProperties
}
